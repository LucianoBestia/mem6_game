{
  "tour": "start_route_template_render_tour",
  "title": "start_route_template_render_tour",
  "steps": [
    {
      "file": "webfolder/mem6/index.html",
      "line": 82,
      "description": "### index.html wasm import script\nThe browser downloads the index.html file as usual. \nThis <script> element imports and init the wasm code.  \nA simple web file server is enough. \nWarning: the index.html cannot be served from local file without a server, because importing modules is not allowed then for security reasons.\nI will try to use only Rust+Wasm and avoid JavaScript as much as possible.",
      "selection": {
        "start": {
          "line": 78,
          "character": 1
        },
        "end": {
          "line": 82,
          "character": 16
        }
      },
      "contents": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n      <!-- classic header for a web page -->\r\n      <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\" />\r\n      <title>mem6</title>\r\n      <meta name=\"Description\"\r\n            content=\"UnForGetTable - a drinking game to lose memory\">\r\n      <link rel=\"stylesheet\" href=\"css/mem6.css\">\r\n      <meta name=\"viewport\"\r\n            content=\"width = device-width,initial-scale = 1.0\" />\r\n      <!-- A lot of metadata for PWA -->\r\n      <link rel=\"manifest\" href=\"manifest.json\">\r\n      <meta name=\"mobile-web-app-capable\" content=\"yes\">\r\n      <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\r\n      <meta name=\"apple-mobile-web-app-status-bar-style\"\r\n            content=\"black-translucent\" />\r\n      <meta name=\"theme-color\" content=\"#FFFF00\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"57x57\"\r\n            href=\"images/apple-icon-57x57.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"60x60\"\r\n            href=\"images/apple-icon-60x60.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"72x72\"\r\n            href=\"images/apple-icon-72x72.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"76x76\"\r\n            href=\"images/apple-icon-76x76.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"114x114\"\r\n            href=\"images/apple-icon-114x114.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"120x120\"\r\n            href=\"images/apple-icon-120x120.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"144x144\"\r\n            href=\"images/apple-icon-144x144.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"152x152\"\r\n            href=\"images/apple-icon-152x152.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"180x180\"\r\n            href=\"images/apple-icon-180x180.png\">\r\n      <link rel=\"apple-touch-icon\" href=\"images/icons-192.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"192x192\"\r\n            href=\"images/android-icon-192x192.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\"\r\n            href=\"images/favicon-32x32.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"96x96\"\r\n            href=\"images/favicon-96x96.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\"\r\n            href=\"images/favicon-16x16.png\">\r\n      <link rel=\"icon\" type=\"image/png\" href=\"images/icons-512.png\"\r\n            sizes=\"512x512\">\r\n      <meta name=\"msapplication-TileColor\" content=\"#FFFF00\">\r\n      <meta name=\"msapplication-TileImage\" content=\"images/ms-icon-144x144.png\">\r\n\r\n</head>\r\n\r\n<body>\r\n      <!-- a standard service worker is a must for PWA -->\r\n      <script src=\"start_service_worker.js\"></script>\r\n      <!-- warning if javascript iis not enabled -->\r\n      <noscript>\r\n            <h2>\r\n                  !!!???!!!<br>\r\n                  This game <br>\r\n                  cannot work <br>\r\n                  without javascript<br>\r\n                  enabled<br>\r\n                  !!!???!!!</h2>\r\n      </noscript>\r\n      <!-- display a text while waiting for wasm download. It can take some time. -->\r\n      <div id=\"div_for_virtual_dom\">\r\n            <h2>\r\n                  Waiting to<br>\r\n                  download <br>\r\n                  the game...<br>\r\n                  This is <br>\r\n                  very quick on fast<br>\r\n                  networks...<br>\r\n            </h2>\r\n      </div>\r\n      <!-- import and init the wasm code -->\r\n      <script type=\"module\">\r\n            import init from \"./pkg/mem6.js\";\r\n            init(\"./pkg/mem6_bg.wasm\");\r\n      </script>\r\n</body>\r\n\r\n</html>"
    },
    {
      "file": "mem6/src/lib.rs",
      "line": 299,
      "description": "### wasm_bindgen_start\nRust is a great language to compile to Wasm/WebAssembly.\nWith the use of libraries wasm_bindgen, web_sys and js_sys Rust has access to the browser javascript environment. So it can do most of the things that JavaScript can do.  \nThe imported Wasm module will automatically start the function with attribute `#[wasm_bindgen(start)]`. This function is called only once. ",
      "selection": {
        "start": {
          "line": 296,
          "character": 1
        },
        "end": {
          "line": 296,
          "character": 23
        }
      },
      "contents": "#![doc(\n    html_favicon_url = \"https://github.com/LucianoBestia/mem6_game/raw/master/webfolder/mem6/images/icons-16.png\"\n)]\n#![doc(\n    html_logo_url = \"https://github.com/LucianoBestia/mem6_game/raw/master/webfolder/mem6/images/icons-192.png\"\n)]\n// region: lmake_readme insert \"readme.md\"\n//! # unForGetTable  (development name: mem6)\n//!\n//! version: 2020.225.1404  \n//!\n//! mem6 is a simple drinking game to lose memory. It is made primarily for learning the Rust programming language and Wasm/WebAssembly with Virtual Dom Dodrio, WebSocket communication and PWA (Progressive Web App).  \n//!\n//! ## Idea\n//!\n//! Playing the memory game alone is boring.  \n//! Playing it with friends is better. Playing with drinking friends is even better. More friends - more fun.  \n//! I hope you have at least 3 or 4 friends now and all of you are around the same table.  \n//! The first player opens bestia.dev/mem6 and starts the group. Other players scan the QR code and join the same group. Then put all phones on the table near to each other. It will look as a \"big\" board game.  \n//! The game is hyper simple: every player opens 2 cards. If the cards are the same, you drink. If not you don't drink. Then the next player opens 2 cards. And so on...\n//!\n//! ## Rust and Wasm/WebAssembly\n//!\n//! Rust is a pretty new language created by Mozilla for really low level programming.  \n//! It is a step forward from the C language with functionality and features that are best practice today.  \n//! It is pretty hard to learn. Some concepts are so different from other languages it makes it\n//! hard for beginners. Lifetimes are the strangest and most confusing concept.  \n//! The Rust language has been made from the ground up with an ecosystem that makes it productive.  \n//! The language and most of the libraries are Open Source. That is good and bad, but mostly good.  \n//! Rust is the best language today to compile into Wasm/WebAssembly.  \n//! That compiled code works inside a browser directly with the JavaScript engine.  \n//! So finally no need for JavaScript to make cross-platform applications inside browsers.  \n//! I have a lot of hope here.  \n//!\n//! ## Virtual DOM\n//!\n//! Constructing a HTML page with Virtual DOM (vdom) is easier because it is scheduled to render completely on the next tick (animation frame). We can use the term here \"state machine\". The rendering depends only on the state of the data and not on the history of the changes.  \n//! Sometimes is very complex what should change in the UI when some data changes.  \n//! The data can change from many different events and very chaotically (asynchronously).  \n//! It is easier to think how to render the complete DOM for a given state of data.  \n//! The Rust Dodrio library has ticks, time intervals when it does something. If a rendering is scheduled, it will be done on the next tick. If a rendering is not scheduled I believe nothing happens.  \n//! This enables asynchronous changing of data and rendering. They cannot happen theoretically in the\n//! same exact moment. So, no data race here.  \n//! When GameData change and we know it will affect the DOM, then rendering must be scheduled.  \n//! The main component of the Dodrio Virtual Dom is the Root Rendering Component (rrc).  \n//! It is the component that renders the complete user interface (HTML) and contains all the data state.  \n//!\n//! ## GameData\n//!\n//! All the game data state are in this simple struct inside the Root Rendering Component.  \n//!\n//! ## WebSocket communication\n//!\n//! HTML5 has finally bring a true stateful bidirectional communication.  \n//! Most of the programming problems are more easily and effectively solved this way.  \n//! The old unidirectional stateless communication is very good for static html pages, but is terrible for any dynamic page. The WebSocket is very rudimental and often the communication breaks for many different reasons. The programmer must deal with it inside the application.  \n//! I send simple structs text messages in json format between the players. They are all in the WsMsg enum and therefore easy to use by the server and client.  \n//! The WebSocket server is coded especially for this game and recognizes the players string that has a vector of ws_uid to whom send the message.  \n//!\n//! ## WebSockets is not reliable\n//!\n//! Simple messaging is not reliable. On mobiles it is even worse. There is a lot of possibilities that something goes wrong and the message doesn't reach the destination. The protocol has nothing that can be used to deal with reconnections or lost messages.  \n//! That means that I need additional work on the application level - always reply one acknowledgement \"ack\" message.  \n//! Workflow:  \n//!\n//! - sender sends one message to more players (more ws_uid) with one random number msg_id\n//!     push to a vector (msg queue) more items with ws_uid and msg_id\n//!     blocks the continuation of the workflow until receives all ACK from all players\n//!\n//! - receiver on receive send the ACK acknowledge msg with his ws_uid and msg_id\n//!\n//! - the sender receives the ACK and removes one item from the vector\n//!     if there is no more items for that msg_id, the workflow can continue.\n//!     TODO: if after 3 seconds the ACK is not received and error message is shown to the player.\n//!\n//! This is very similar to a message queue...  \n//!\n//! ## gRPC, WebRTC datachannel\n//!\n//! The new shiny protocol gRPC for web communication is great for server-to-server communication. But it is still very limited inside the browser. When it eventually becomes stable I would like to change WebSockets for gRPC.  \n//! The WebRTC datachannel sounds great for peer-to-peer communication. Very probably the players will be all on the same wifi network, this solves all latency issues.  \n//! TODO: try to add this to version 6.  \n//!\n//! ## The game flow\n//!\n//! In a few words:  \n//! Playing player : Status1 - user action - send msg - await for ack msgs - update game data - Status2  \n//! Other players: Status1 - receive WsMessage - send ack msg - update game data - Status2  \n//!\n//! In one moment the game is in a one Game Status for all players.  \n//! One player is the playing player and all others are awaiting.  \n//! The active user then makes an action on the GUI.\n//! This action will eventually change the GameData and the GameStatus. But before that there is communication.  \n//! A message is sent to other players so they can also change their local GameData and GameStatus.  \n//! Because of unreliable networks there must be an acknowledge ack msg to confirm, that the msg is received to continue the game.  \n//! The rendering is scheduled and it will happen shortly (async).  \n//!\n//! ## Futures and Promises, Rust and JavaScript\n//!\n//! JavaScript is all asynchronous. Wasm is nothing else then a shortcut to the JavaScript engine.  \n//! So everything is asynchronous too. This is pretty hard to grasp. Everything is Promises and Futures. Fortunately lately there is async/await for Rust and it is great for dealing with javascript.  \n//! JavaScript does not have a good idea of Rust datatypes. All there is is a generic JSValue type.  \n//! The library `wasm-bindgen` has made a fantastic job of giving Rust the ability to call\n//! anything JavaScript can call, but the way of doing it is sometimes cumbersome.  \n//!\n//! ## Html templating\n//!\n//! In the past I wrote html inside Rust code with the macro `html!` from the `crate typed-html`  \n//! <https://github.com/bodil/typed-html>  \n//! It has also a macro `dodrio !` created exclusively for the dodrio vdom.  \n//! I had two main problems with this approach:  \n//!\n//! 1. Any change to the html required a recompiling. And that is very slow in Rust.  \n//! 2. I could not add new html elements, that the macro don't recognize. I wanted to use SVG. There was not support for that.  \n//!\n//! I reinvented \"html templating\".  \n//! First a graphical designer makes a html/css page that looks nice. No javascript, nothing is dynamic. It is just a graphical template.  \n//! Then I insert in it html comments and \"data-\" attributes that I can later replace in my code.  \n//! The html is not changed graphically because of it. So both the graphical designer and the programmer are still happy.  \n//! In my code I parse the html template as a microXml file. Basically they are the same with small effort. When I find a comment or \"data-\" attribute then the value of the next node is replaced.  \n//! I can replace attributes, strings and entire nodes. And I can insert event for behavior with \"data-t\".  \n//! When developing, the html template is loaded and parsed and a dodrio node is created. That is not very fast. But I can change the html in real time and see it rendered without compiling the Rust code. This is super efficient for development.  \n//! I have in plans to add a Rust code generator, that creates the Rust code for the dodrio node before compile time. In that case nothing is parsed in runtime and I expect great speeds. But the flexibility of easily changing the html template is gone. For every change I must recompile the Rust code.  \n//!\n//! ## Browser console\n//!\n//! At least in modern browsers (Firefox and Chrome) we have the developer tools F12 and there is a\n//! console we can output to. So we can debug what is going on with our Wasm program.\n//! But not on smartphones !! I save the error and log messages in session_storage and this is displayed on the screen.  \n//!\n//! ## Safari on iOS and FullScreen\n//!\n//! Apple is very restrictive and does not allow fullscreen Safari on iPhones.  \n//! The workaround is to `Add to HomeScreen` the webapp.  \n//!\n//! ## PWA (Progressive Web App)\n//!\n//! On both android and iPhone is possible to use PWA.  \n//! To be 100% PWA it must be secured with TLS and must have a service worker.  \n//! I added also the PWA manifest and png images for icons and now the game is a full PWA.  \n//!\n//! **Very important :**\n//! On Android Chrome to `Clear & reset` the cached data of the website you must click on the icon of the URL address (the lock) and choose `Site Settings`.  \n//! Sometimes even that does not work. Than I go in the Menu to Settings - Privacy - Clear browser data and delete all. Very aggressive, but the only way I found that works.  \n//!\n//! ## Modules\n//!\n//! Rust code is splitted into modules. They are not exactly like classes, but can be similar.  \n//! Rust has much more freedom to group code in different ways. So that is best suits the problem.  \n//! I splitted the rendering pages and that into sub-components.  \n//! And then I splitted the User Actions by the Status1 to easy follow the flow of the game.  \n//!\n//! ## State machine\n//!\n//! I try to use the philosophy of \"state machine\" because it is easier to follow.  \n//! All is dependent on the state of the data and not on the chronological events.  \n//! Any event can change the state/data. Then another piece of code will do the rest\n//! based on the state/data. The data can come from different places: user input, fetch from\n//! web, url/hash, local_storage. It doesn't matter. All the data must first go into the state/data.  \n//! Then some other code makes decision based on the state/data.  \n//! The app is divided in 2 ways:\n//!\n//! - visually it is divided in pages and page components\n//! - behaviorally is divided into pages and game_state\n//!\n//! ## Clippy\n//!\n//! Clippy is very useful to teach us how to program Rust in a better way.  \n//! These are not syntax errors, but hints how to do it in a more Rusty way (idiomatic).  \n//! Some lints are problematic and they are explicitly allowed here.\n//!\n//! ## font-size\n//!\n//! Browsers have 2 types of zoom:\n//!\n//! - zoom everything proportionally (I like this.)\n//! - zoom only the text (I hate this: it breaks the layout completely.)\n//!\n//! When the font-size in android is increased (accessibility) it applies somehow also to the browser rendering.  \n//! I have tried many different things, but it looks this cannot be overridden from the css or javascript. Only the user can change this setting in his phone.  \n//!\n//! ## SVG\n//!\n//! This is why I chose to use SVG for my html templates. Svg promises that the user cannot ruin the layout completely. But also SVG has its set of complication small and big.  \n//! It is annoying that SVG must use namespaces for all the elements and subelements.  \n//! I will use percents to define x, y, width and height. Because for the game is only logical to be always full screen.\n//!\n//! ## font-family\n//!\n//! The size of the font depends a lot of the font-family. Every browser show different fonts\n//! even when they call them the same. I need to use a third-party web font. Google seems to\n//! be a good source of free fonts. I choose Roboto. Having them download every time from google is time consuming. So I will download them and host them locally on my website.  \n//! I use the <https://google-webfonts-helper.herokuapp.com> to download fonts.  \n//!\n//! ## favicon.ico\n//!\n//! Crazy stuff. I used the website <https://www.favicon-generator.org/> to generate\n//! all the different imgs, sizes and code. And than add all this into index.html. There is more lines for icons than anything else now. Just crazy world.  \n\n// endregion: lmake_readme insert \"readme.md\"\n\n// needed for dodrio ! macro (typed-html)\n#![recursion_limit = \"512\"]\n// region: Clippy\n#![warn(\n    clippy::all,\n    clippy::restriction,\n    clippy::pedantic,\n    clippy::nursery,\n    clippy::cargo,\n    // variable shadowing is idiomatic to Rust, but unnatural to me.\n    clippy::shadow_reuse,\n    clippy::shadow_same,\n    clippy::shadow_unrelated,\n\n)]\n#![allow(\n    // library from dependencies have this clippy warnings. Not my code.\n    // Why is this bad: It will be more difficult for users to discover the purpose of the crate, \n    // and key information related to it.\n    clippy::cargo_common_metadata,\n    // Why is this bad : This bloats the size of targets, and can lead to confusing error messages when \n    // structs or traits are used interchangeably between different versions of a crate.\n    clippy::multiple_crate_versions,\n    // Why is this bad : As the edition guide says, it is highly unlikely that you work with any possible \n    // version of your dependency, and wildcard dependencies would cause unnecessary \n    // breakage in the ecosystem.\n    clippy::wildcard_dependencies,\n    // Rust is more idiomatic without return statement\n    // Why is this bad : Actually omitting the return keyword is idiomatic Rust code. \n    // Programmers coming from other languages might prefer the expressiveness of return. \n    // It’s possible to miss the last returning statement because the only difference \n    // is a missing ;. Especially in bigger code with multiple return paths having a \n    // return keyword makes it easier to find the corresponding statements.\n    clippy::implicit_return,\n    // I have private function inside a function. Self does not work there.\n    // Why is this bad: Unnecessary repetition. Mixed use of Self and struct name feels inconsistent.\n    clippy::use_self,\n    // Cannot add #[inline] to the start function with #[wasm_bindgen(start)]\n    // because then wasm-pack build --target web returns an error: export run not found \n    // Why is this bad: In general, it is not. Functions can be inlined across crates when that’s profitable \n    // as long as any form of LTO is used. When LTO is disabled, functions that are not #[inline] \n    // cannot be inlined across crates. Certain types of crates might intend for most of the \n    // methods in their public API to be able to be inlined across crates even when LTO is disabled. \n    // For these types of crates, enabling this lint might make sense. It allows the crate to \n    // require all exported methods to be #[inline] by default, and then opt out for specific \n    // methods where this might not make sense.\n    clippy::missing_inline_in_public_items,\n    // Why is this bad: This is only checked against overflow in debug builds. In some applications one wants explicitly checked, wrapping or saturating arithmetic.\n    // clippy::integer_arithmetic,\n    // Why is this bad: For some embedded systems or kernel development, it can be useful to rule out floating-point numbers.\n    clippy::float_arithmetic,\n    // Why is this bad : Doc is good. rustc has a MISSING_DOCS allowed-by-default lint for public members, but has no way to enforce documentation of private items. This lint fixes that.\n    clippy::doc_markdown,\n    // Why is this bad : Splitting the implementation of a type makes the code harder to navigate.\n    clippy::multiple_inherent_impl,\n)]\n// endregion\n\n// region: mod is used only in lib file. All the rest use use crate\nmod ackmsgmod;\nmod divgridcontainermod;\nmod divplayeractionsmod;\nmod fetchmod;\nmod gamedatamod;\nmod rootrenderingcomponentmod;\nmod storagemod;\nmod statusgamedatainitmod;\nmod statusgameovermod;\nmod statusjoinedmod;\nmod status1stcardmod;\nmod status2ndcardmod;\nmod statusdrinkmod;\nmod statustaketurnmod;\nmod statuswaitingackmsgmod;\nmod websocketboilermod;\nmod websocketspecmod;\nmod statusreconnectmod;\nmod routerimplmod;\nmod htmltemplateimplmod;\nmod webdatamod;\nmod webrtcimplmod;\n// endregion\n\n// this are then used in all the mods if I have there use crate::*;\nuse crate::rootrenderingcomponentmod::RootRenderingComponent;\nuse crate::gamedatamod::*;\n\nuse rust_wasm_dodrio_templating::*;\nuse rust_wasm_websys_utils::*;\n//use rust_wasm_websocket::*;\n\n// use unwrap::unwrap;\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen(start)]\n#[allow(clippy::shadow_same)]\n/// To start the Wasm application, wasm_bindgen runs this functions\npub fn wasm_bindgen_start() -> Result<(), JsValue> {\n    // Initialize debugging for when/if something goes wrong.\n    console_error_panic_hook::set_once();\n\n    websysmod::debug_write(&format!(\"wasm app version: {}\", env!(\"CARGO_PKG_VERSION\")));\n\n    // Get the container to render the virtual Dom component.\n    let div_for_virtual_dom = websysmod::get_element_by_id(\"div_for_virtual_dom\");\n\n    // load from storage or get random (and then save)\n    let my_ws_uid = websocketboilermod::load_or_random_ws_uid();\n    let (location_href, href_hash) = websysmod::get_url_and_hash();\n    // Construct a new RootRenderingComponent.\n    let mut rrc = RootRenderingComponent::new(my_ws_uid);\n    rrc.web_data.href = location_href.to_string();\n    rrc.web_data.href_hash = href_hash;\n    // Mount the component to the `<div id=\"div_for_virtual_dom\">`.\n    let vdom_object = dodrio::Vdom::new(&div_for_virtual_dom, rrc);\n    let vdom = vdom_object.weak();\n    // async fetch_response() for gamesmetadata.json\n    fetchmod::fetch_games_metadata_and_update(&location_href, vdom.clone());\n    fetchmod::fetch_videos_and_update(&location_href, vdom.clone());\n    fetchmod::fetch_audio_and_update(&location_href, vdom.clone());\n    // Start the URL router.\n    use rust_wasm_router::routermod::RouterTrait;\n    let router = routerimplmod::Router::new();\n    router.start_router(vdom.clone());\n\n    // Run the component forever. Forget to drop the memory.\n    vdom_object.forget();\n\n    Ok(())\n}\n"
    },
    {
      "file": "mem6/src/lib.rs",
      "line": 306,
      "description": "### div_for_virtual_dom\nThe Rust code will change just the content of the <div id=\"div_for_virtual_dom\">. \nThis is a \"single page web app\". For the browser the index.html is always the same, we only change the interior content of it's dom. ",
      "selection": {
        "start": {
          "line": 306,
          "character": 61
        },
        "end": {
          "line": 306,
          "character": 80
        }
      },
      "contents": "#![doc(\n    html_favicon_url = \"https://github.com/LucianoBestia/mem6_game/raw/master/webfolder/mem6/images/icons-16.png\"\n)]\n#![doc(\n    html_logo_url = \"https://github.com/LucianoBestia/mem6_game/raw/master/webfolder/mem6/images/icons-192.png\"\n)]\n// region: lmake_readme insert \"readme.md\"\n//! # unForGetTable  (development name: mem6)\n//!\n//! version: 2020.225.1404  \n//!\n//! mem6 is a simple drinking game to lose memory. It is made primarily for learning the Rust programming language and Wasm/WebAssembly with Virtual Dom Dodrio, WebSocket communication and PWA (Progressive Web App).  \n//!\n//! ## Idea\n//!\n//! Playing the memory game alone is boring.  \n//! Playing it with friends is better. Playing with drinking friends is even better. More friends - more fun.  \n//! I hope you have at least 3 or 4 friends now and all of you are around the same table.  \n//! The first player opens bestia.dev/mem6 and starts the group. Other players scan the QR code and join the same group. Then put all phones on the table near to each other. It will look as a \"big\" board game.  \n//! The game is hyper simple: every player opens 2 cards. If the cards are the same, you drink. If not you don't drink. Then the next player opens 2 cards. And so on...\n//!\n//! ## Rust and Wasm/WebAssembly\n//!\n//! Rust is a pretty new language created by Mozilla for really low level programming.  \n//! It is a step forward from the C language with functionality and features that are best practice today.  \n//! It is pretty hard to learn. Some concepts are so different from other languages it makes it\n//! hard for beginners. Lifetimes are the strangest and most confusing concept.  \n//! The Rust language has been made from the ground up with an ecosystem that makes it productive.  \n//! The language and most of the libraries are Open Source. That is good and bad, but mostly good.  \n//! Rust is the best language today to compile into Wasm/WebAssembly.  \n//! That compiled code works inside a browser directly with the JavaScript engine.  \n//! So finally no need for JavaScript to make cross-platform applications inside browsers.  \n//! I have a lot of hope here.  \n//!\n//! ## Virtual DOM\n//!\n//! Constructing a HTML page with Virtual DOM (vdom) is easier because it is scheduled to render completely on the next tick (animation frame). We can use the term here \"state machine\". The rendering depends only on the state of the data and not on the history of the changes.  \n//! Sometimes is very complex what should change in the UI when some data changes.  \n//! The data can change from many different events and very chaotically (asynchronously).  \n//! It is easier to think how to render the complete DOM for a given state of data.  \n//! The Rust Dodrio library has ticks, time intervals when it does something. If a rendering is scheduled, it will be done on the next tick. If a rendering is not scheduled I believe nothing happens.  \n//! This enables asynchronous changing of data and rendering. They cannot happen theoretically in the\n//! same exact moment. So, no data race here.  \n//! When GameData change and we know it will affect the DOM, then rendering must be scheduled.  \n//! The main component of the Dodrio Virtual Dom is the Root Rendering Component (rrc).  \n//! It is the component that renders the complete user interface (HTML) and contains all the data state.  \n//!\n//! ## GameData\n//!\n//! All the game data state are in this simple struct inside the Root Rendering Component.  \n//!\n//! ## WebSocket communication\n//!\n//! HTML5 has finally bring a true stateful bidirectional communication.  \n//! Most of the programming problems are more easily and effectively solved this way.  \n//! The old unidirectional stateless communication is very good for static html pages, but is terrible for any dynamic page. The WebSocket is very rudimental and often the communication breaks for many different reasons. The programmer must deal with it inside the application.  \n//! I send simple structs text messages in json format between the players. They are all in the WsMsg enum and therefore easy to use by the server and client.  \n//! The WebSocket server is coded especially for this game and recognizes the players string that has a vector of ws_uid to whom send the message.  \n//!\n//! ## WebSockets is not reliable\n//!\n//! Simple messaging is not reliable. On mobiles it is even worse. There is a lot of possibilities that something goes wrong and the message doesn't reach the destination. The protocol has nothing that can be used to deal with reconnections or lost messages.  \n//! That means that I need additional work on the application level - always reply one acknowledgement \"ack\" message.  \n//! Workflow:  \n//!\n//! - sender sends one message to more players (more ws_uid) with one random number msg_id\n//!     push to a vector (msg queue) more items with ws_uid and msg_id\n//!     blocks the continuation of the workflow until receives all ACK from all players\n//!\n//! - receiver on receive send the ACK acknowledge msg with his ws_uid and msg_id\n//!\n//! - the sender receives the ACK and removes one item from the vector\n//!     if there is no more items for that msg_id, the workflow can continue.\n//!     TODO: if after 3 seconds the ACK is not received and error message is shown to the player.\n//!\n//! This is very similar to a message queue...  \n//!\n//! ## gRPC, WebRTC datachannel\n//!\n//! The new shiny protocol gRPC for web communication is great for server-to-server communication. But it is still very limited inside the browser. When it eventually becomes stable I would like to change WebSockets for gRPC.  \n//! The WebRTC datachannel sounds great for peer-to-peer communication. Very probably the players will be all on the same wifi network, this solves all latency issues.  \n//! TODO: try to add this to version 6.  \n//!\n//! ## The game flow\n//!\n//! In a few words:  \n//! Playing player : Status1 - user action - send msg - await for ack msgs - update game data - Status2  \n//! Other players: Status1 - receive WsMessage - send ack msg - update game data - Status2  \n//!\n//! In one moment the game is in a one Game Status for all players.  \n//! One player is the playing player and all others are awaiting.  \n//! The active user then makes an action on the GUI.\n//! This action will eventually change the GameData and the GameStatus. But before that there is communication.  \n//! A message is sent to other players so they can also change their local GameData and GameStatus.  \n//! Because of unreliable networks there must be an acknowledge ack msg to confirm, that the msg is received to continue the game.  \n//! The rendering is scheduled and it will happen shortly (async).  \n//!\n//! ## Futures and Promises, Rust and JavaScript\n//!\n//! JavaScript is all asynchronous. Wasm is nothing else then a shortcut to the JavaScript engine.  \n//! So everything is asynchronous too. This is pretty hard to grasp. Everything is Promises and Futures. Fortunately lately there is async/await for Rust and it is great for dealing with javascript.  \n//! JavaScript does not have a good idea of Rust datatypes. All there is is a generic JSValue type.  \n//! The library `wasm-bindgen` has made a fantastic job of giving Rust the ability to call\n//! anything JavaScript can call, but the way of doing it is sometimes cumbersome.  \n//!\n//! ## Html templating\n//!\n//! In the past I wrote html inside Rust code with the macro `html!` from the `crate typed-html`  \n//! <https://github.com/bodil/typed-html>  \n//! It has also a macro `dodrio !` created exclusively for the dodrio vdom.  \n//! I had two main problems with this approach:  \n//!\n//! 1. Any change to the html required a recompiling. And that is very slow in Rust.  \n//! 2. I could not add new html elements, that the macro don't recognize. I wanted to use SVG. There was not support for that.  \n//!\n//! I reinvented \"html templating\".  \n//! First a graphical designer makes a html/css page that looks nice. No javascript, nothing is dynamic. It is just a graphical template.  \n//! Then I insert in it html comments and \"data-\" attributes that I can later replace in my code.  \n//! The html is not changed graphically because of it. So both the graphical designer and the programmer are still happy.  \n//! In my code I parse the html template as a microXml file. Basically they are the same with small effort. When I find a comment or \"data-\" attribute then the value of the next node is replaced.  \n//! I can replace attributes, strings and entire nodes. And I can insert event for behavior with \"data-t\".  \n//! When developing, the html template is loaded and parsed and a dodrio node is created. That is not very fast. But I can change the html in real time and see it rendered without compiling the Rust code. This is super efficient for development.  \n//! I have in plans to add a Rust code generator, that creates the Rust code for the dodrio node before compile time. In that case nothing is parsed in runtime and I expect great speeds. But the flexibility of easily changing the html template is gone. For every change I must recompile the Rust code.  \n//!\n//! ## Browser console\n//!\n//! At least in modern browsers (Firefox and Chrome) we have the developer tools F12 and there is a\n//! console we can output to. So we can debug what is going on with our Wasm program.\n//! But not on smartphones !! I save the error and log messages in session_storage and this is displayed on the screen.  \n//!\n//! ## Safari on iOS and FullScreen\n//!\n//! Apple is very restrictive and does not allow fullscreen Safari on iPhones.  \n//! The workaround is to `Add to HomeScreen` the webapp.  \n//!\n//! ## PWA (Progressive Web App)\n//!\n//! On both android and iPhone is possible to use PWA.  \n//! To be 100% PWA it must be secured with TLS and must have a service worker.  \n//! I added also the PWA manifest and png images for icons and now the game is a full PWA.  \n//!\n//! **Very important :**\n//! On Android Chrome to `Clear & reset` the cached data of the website you must click on the icon of the URL address (the lock) and choose `Site Settings`.  \n//! Sometimes even that does not work. Than I go in the Menu to Settings - Privacy - Clear browser data and delete all. Very aggressive, but the only way I found that works.  \n//!\n//! ## Modules\n//!\n//! Rust code is splitted into modules. They are not exactly like classes, but can be similar.  \n//! Rust has much more freedom to group code in different ways. So that is best suits the problem.  \n//! I splitted the rendering pages and that into sub-components.  \n//! And then I splitted the User Actions by the Status1 to easy follow the flow of the game.  \n//!\n//! ## State machine\n//!\n//! I try to use the philosophy of \"state machine\" because it is easier to follow.  \n//! All is dependent on the state of the data and not on the chronological events.  \n//! Any event can change the state/data. Then another piece of code will do the rest\n//! based on the state/data. The data can come from different places: user input, fetch from\n//! web, url/hash, local_storage. It doesn't matter. All the data must first go into the state/data.  \n//! Then some other code makes decision based on the state/data.  \n//! The app is divided in 2 ways:\n//!\n//! - visually it is divided in pages and page components\n//! - behaviorally is divided into pages and game_state\n//!\n//! ## Clippy\n//!\n//! Clippy is very useful to teach us how to program Rust in a better way.  \n//! These are not syntax errors, but hints how to do it in a more Rusty way (idiomatic).  \n//! Some lints are problematic and they are explicitly allowed here.\n//!\n//! ## font-size\n//!\n//! Browsers have 2 types of zoom:\n//!\n//! - zoom everything proportionally (I like this.)\n//! - zoom only the text (I hate this: it breaks the layout completely.)\n//!\n//! When the font-size in android is increased (accessibility) it applies somehow also to the browser rendering.  \n//! I have tried many different things, but it looks this cannot be overridden from the css or javascript. Only the user can change this setting in his phone.  \n//!\n//! ## SVG\n//!\n//! This is why I chose to use SVG for my html templates. Svg promises that the user cannot ruin the layout completely. But also SVG has its set of complication small and big.  \n//! It is annoying that SVG must use namespaces for all the elements and subelements.  \n//! I will use percents to define x, y, width and height. Because for the game is only logical to be always full screen.\n//!\n//! ## font-family\n//!\n//! The size of the font depends a lot of the font-family. Every browser show different fonts\n//! even when they call them the same. I need to use a third-party web font. Google seems to\n//! be a good source of free fonts. I choose Roboto. Having them download every time from google is time consuming. So I will download them and host them locally on my website.  \n//! I use the <https://google-webfonts-helper.herokuapp.com> to download fonts.  \n//!\n//! ## favicon.ico\n//!\n//! Crazy stuff. I used the website <https://www.favicon-generator.org/> to generate\n//! all the different imgs, sizes and code. And than add all this into index.html. There is more lines for icons than anything else now. Just crazy world.  \n\n// endregion: lmake_readme insert \"readme.md\"\n\n// needed for dodrio ! macro (typed-html)\n#![recursion_limit = \"512\"]\n// region: Clippy\n#![warn(\n    clippy::all,\n    clippy::restriction,\n    clippy::pedantic,\n    clippy::nursery,\n    clippy::cargo,\n    // variable shadowing is idiomatic to Rust, but unnatural to me.\n    clippy::shadow_reuse,\n    clippy::shadow_same,\n    clippy::shadow_unrelated,\n\n)]\n#![allow(\n    // library from dependencies have this clippy warnings. Not my code.\n    // Why is this bad: It will be more difficult for users to discover the purpose of the crate, \n    // and key information related to it.\n    clippy::cargo_common_metadata,\n    // Why is this bad : This bloats the size of targets, and can lead to confusing error messages when \n    // structs or traits are used interchangeably between different versions of a crate.\n    clippy::multiple_crate_versions,\n    // Why is this bad : As the edition guide says, it is highly unlikely that you work with any possible \n    // version of your dependency, and wildcard dependencies would cause unnecessary \n    // breakage in the ecosystem.\n    clippy::wildcard_dependencies,\n    // Rust is more idiomatic without return statement\n    // Why is this bad : Actually omitting the return keyword is idiomatic Rust code. \n    // Programmers coming from other languages might prefer the expressiveness of return. \n    // It’s possible to miss the last returning statement because the only difference \n    // is a missing ;. Especially in bigger code with multiple return paths having a \n    // return keyword makes it easier to find the corresponding statements.\n    clippy::implicit_return,\n    // I have private function inside a function. Self does not work there.\n    // Why is this bad: Unnecessary repetition. Mixed use of Self and struct name feels inconsistent.\n    clippy::use_self,\n    // Cannot add #[inline] to the start function with #[wasm_bindgen(start)]\n    // because then wasm-pack build --target web returns an error: export run not found \n    // Why is this bad: In general, it is not. Functions can be inlined across crates when that’s profitable \n    // as long as any form of LTO is used. When LTO is disabled, functions that are not #[inline] \n    // cannot be inlined across crates. Certain types of crates might intend for most of the \n    // methods in their public API to be able to be inlined across crates even when LTO is disabled. \n    // For these types of crates, enabling this lint might make sense. It allows the crate to \n    // require all exported methods to be #[inline] by default, and then opt out for specific \n    // methods where this might not make sense.\n    clippy::missing_inline_in_public_items,\n    // Why is this bad: This is only checked against overflow in debug builds. In some applications one wants explicitly checked, wrapping or saturating arithmetic.\n    // clippy::integer_arithmetic,\n    // Why is this bad: For some embedded systems or kernel development, it can be useful to rule out floating-point numbers.\n    clippy::float_arithmetic,\n    // Why is this bad : Doc is good. rustc has a MISSING_DOCS allowed-by-default lint for public members, but has no way to enforce documentation of private items. This lint fixes that.\n    clippy::doc_markdown,\n    // Why is this bad : Splitting the implementation of a type makes the code harder to navigate.\n    clippy::multiple_inherent_impl,\n)]\n// endregion\n\n// region: mod is used only in lib file. All the rest use use crate\nmod ackmsgmod;\nmod divgridcontainermod;\nmod divplayeractionsmod;\nmod fetchmod;\nmod gamedatamod;\nmod rootrenderingcomponentmod;\nmod storagemod;\nmod statusgamedatainitmod;\nmod statusgameovermod;\nmod statusjoinedmod;\nmod status1stcardmod;\nmod status2ndcardmod;\nmod statusdrinkmod;\nmod statustaketurnmod;\nmod statuswaitingackmsgmod;\nmod websocketboilermod;\nmod websocketspecmod;\nmod statusreconnectmod;\nmod routerimplmod;\nmod htmltemplateimplmod;\nmod webdatamod;\nmod webrtcimplmod;\n// endregion\n\n// this are then used in all the mods if I have there use crate::*;\nuse crate::rootrenderingcomponentmod::RootRenderingComponent;\nuse crate::gamedatamod::*;\n\nuse rust_wasm_dodrio_templating::*;\nuse rust_wasm_websys_utils::*;\n//use rust_wasm_websocket::*;\n\n// use unwrap::unwrap;\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen(start)]\n#[allow(clippy::shadow_same)]\n/// To start the Wasm application, wasm_bindgen runs this functions\npub fn wasm_bindgen_start() -> Result<(), JsValue> {\n    // Initialize debugging for when/if something goes wrong.\n    console_error_panic_hook::set_once();\n\n    websysmod::debug_write(&format!(\"wasm app version: {}\", env!(\"CARGO_PKG_VERSION\")));\n\n    // Get the container to render the virtual Dom component.\n    let div_for_virtual_dom = websysmod::get_element_by_id(\"div_for_virtual_dom\");\n\n    // load from storage or get random (and then save)\n    let my_ws_uid = websocketboilermod::load_or_random_ws_uid();\n    let (location_href, href_hash) = websysmod::get_url_and_hash();\n    // Construct a new RootRenderingComponent.\n    let mut rrc = RootRenderingComponent::new(my_ws_uid);\n    rrc.web_data.href = location_href.to_string();\n    rrc.web_data.href_hash = href_hash;\n    // Mount the component to the `<div id=\"div_for_virtual_dom\">`.\n    let vdom_object = dodrio::Vdom::new(&div_for_virtual_dom, rrc);\n    let vdom = vdom_object.weak();\n    // async fetch_response() for gamesmetadata.json\n    fetchmod::fetch_games_metadata_and_update(&location_href, vdom.clone());\n    fetchmod::fetch_videos_and_update(&location_href, vdom.clone());\n    fetchmod::fetch_audio_and_update(&location_href, vdom.clone());\n    // Start the URL router.\n    use rust_wasm_router::routermod::RouterTrait;\n    let router = routerimplmod::Router::new();\n    router.start_router(vdom.clone());\n\n    // Run the component forever. Forget to drop the memory.\n    vdom_object.forget();\n\n    Ok(())\n}\n"
    },
    {
      "file": "webfolder/mem6/index.html",
      "line": 77,
      "description": "### div_for_virtual_dom in index.html\nThis div is the only part of the index.html that will be dynamically changed by the Rust code.  \nThe download of a big wasm file can take some time on slow network. It is nice to warn the user about that.  ",
      "selection": {
        "start": {
          "line": 67,
          "character": 1
        },
        "end": {
          "line": 77,
          "character": 13
        }
      },
      "contents": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n      <!-- classic header for a web page -->\r\n      <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\" />\r\n      <title>mem6</title>\r\n      <meta name=\"Description\"\r\n            content=\"UnForGetTable - a drinking game to lose memory\">\r\n      <link rel=\"stylesheet\" href=\"css/mem6.css\">\r\n      <meta name=\"viewport\"\r\n            content=\"width = device-width,initial-scale = 1.0\" />\r\n      <!-- A lot of metadata for PWA -->\r\n      <link rel=\"manifest\" href=\"manifest.json\">\r\n      <meta name=\"mobile-web-app-capable\" content=\"yes\">\r\n      <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\r\n      <meta name=\"apple-mobile-web-app-status-bar-style\"\r\n            content=\"black-translucent\" />\r\n      <meta name=\"theme-color\" content=\"#FFFF00\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"57x57\"\r\n            href=\"images/apple-icon-57x57.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"60x60\"\r\n            href=\"images/apple-icon-60x60.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"72x72\"\r\n            href=\"images/apple-icon-72x72.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"76x76\"\r\n            href=\"images/apple-icon-76x76.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"114x114\"\r\n            href=\"images/apple-icon-114x114.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"120x120\"\r\n            href=\"images/apple-icon-120x120.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"144x144\"\r\n            href=\"images/apple-icon-144x144.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"152x152\"\r\n            href=\"images/apple-icon-152x152.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"180x180\"\r\n            href=\"images/apple-icon-180x180.png\">\r\n      <link rel=\"apple-touch-icon\" href=\"images/icons-192.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"192x192\"\r\n            href=\"images/android-icon-192x192.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\"\r\n            href=\"images/favicon-32x32.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"96x96\"\r\n            href=\"images/favicon-96x96.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\"\r\n            href=\"images/favicon-16x16.png\">\r\n      <link rel=\"icon\" type=\"image/png\" href=\"images/icons-512.png\"\r\n            sizes=\"512x512\">\r\n      <meta name=\"msapplication-TileColor\" content=\"#FFFF00\">\r\n      <meta name=\"msapplication-TileImage\" content=\"images/ms-icon-144x144.png\">\r\n\r\n</head>\r\n\r\n<body>\r\n      <!-- a standard service worker is a must for PWA -->\r\n      <script src=\"start_service_worker.js\"></script>\r\n      <!-- warning if javascript iis not enabled -->\r\n      <noscript>\r\n            <h2>\r\n                  !!!???!!!<br>\r\n                  This game <br>\r\n                  cannot work <br>\r\n                  without javascript<br>\r\n                  enabled<br>\r\n                  !!!???!!!</h2>\r\n      </noscript>\r\n      <!-- display a text while waiting for wasm download. It can take some time. -->\r\n      <div id=\"div_for_virtual_dom\">\r\n            <h2>\r\n                  Waiting to<br>\r\n                  download <br>\r\n                  the game...<br>\r\n                  This is <br>\r\n                  very quick on fast<br>\r\n                  networks...<br>\r\n            </h2>\r\n      </div>\r\n      <!-- import and init the wasm code -->\r\n      <script type=\"module\">\r\n            import init from \"./pkg/mem6.js\";\r\n            init(\"./pkg/mem6_bg.wasm\");\r\n      </script>\r\n</body>\r\n\r\n</html>"
    },
    {
      "file": "webfolder/mem6/index.html",
      "line": 66,
      "description": "### noscript warning\nWasm is using the javascript engine deep inside.  \nIf JavaScript is disabled, also wasm cannot run.  ",
      "selection": {
        "start": {
          "line": 57,
          "character": 1
        },
        "end": {
          "line": 66,
          "character": 18
        }
      },
      "contents": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n      <!-- classic header for a web page -->\r\n      <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\" />\r\n      <title>mem6</title>\r\n      <meta name=\"Description\"\r\n            content=\"UnForGetTable - a drinking game to lose memory\">\r\n      <link rel=\"stylesheet\" href=\"css/mem6.css\">\r\n      <meta name=\"viewport\"\r\n            content=\"width = device-width,initial-scale = 1.0\" />\r\n      <!-- A lot of metadata for PWA -->\r\n      <link rel=\"manifest\" href=\"manifest.json\">\r\n      <meta name=\"mobile-web-app-capable\" content=\"yes\">\r\n      <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\r\n      <meta name=\"apple-mobile-web-app-status-bar-style\"\r\n            content=\"black-translucent\" />\r\n      <meta name=\"theme-color\" content=\"#FFFF00\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"57x57\"\r\n            href=\"images/apple-icon-57x57.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"60x60\"\r\n            href=\"images/apple-icon-60x60.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"72x72\"\r\n            href=\"images/apple-icon-72x72.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"76x76\"\r\n            href=\"images/apple-icon-76x76.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"114x114\"\r\n            href=\"images/apple-icon-114x114.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"120x120\"\r\n            href=\"images/apple-icon-120x120.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"144x144\"\r\n            href=\"images/apple-icon-144x144.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"152x152\"\r\n            href=\"images/apple-icon-152x152.png\">\r\n      <link rel=\"apple-touch-icon\" sizes=\"180x180\"\r\n            href=\"images/apple-icon-180x180.png\">\r\n      <link rel=\"apple-touch-icon\" href=\"images/icons-192.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"192x192\"\r\n            href=\"images/android-icon-192x192.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\"\r\n            href=\"images/favicon-32x32.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"96x96\"\r\n            href=\"images/favicon-96x96.png\">\r\n      <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\"\r\n            href=\"images/favicon-16x16.png\">\r\n      <link rel=\"icon\" type=\"image/png\" href=\"images/icons-512.png\"\r\n            sizes=\"512x512\">\r\n      <meta name=\"msapplication-TileColor\" content=\"#FFFF00\">\r\n      <meta name=\"msapplication-TileImage\" content=\"images/ms-icon-144x144.png\">\r\n\r\n</head>\r\n\r\n<body>\r\n      <!-- a standard service worker is a must for PWA -->\r\n      <script src=\"start_service_worker.js\"></script>\r\n      <!-- warning if javascript iis not enabled -->\r\n      <noscript>\r\n            <h2>\r\n                  !!!???!!!<br>\r\n                  This game <br>\r\n                  cannot work <br>\r\n                  without javascript<br>\r\n                  enabled<br>\r\n                  !!!???!!!</h2>\r\n      </noscript>\r\n      <!-- display a text while waiting for wasm download. It can take some time. -->\r\n      <div id=\"div_for_virtual_dom\">\r\n            <h2>\r\n                  Waiting to<br>\r\n                  download <br>\r\n                  the game...<br>\r\n                  This is <br>\r\n                  very quick on fast<br>\r\n                  networks...<br>\r\n            </h2>\r\n      </div>\r\n      <!-- import and init the wasm code -->\r\n      <script type=\"module\">\r\n            import init from \"./pkg/mem6.js\";\r\n            init(\"./pkg/mem6_bg.wasm\");\r\n      </script>\r\n</body>\r\n\r\n</html>"
    },
    {
      "file": "mem6/src/lib.rs",
      "line": 325,
      "description": " ### start_router\n After preparing the environment (websocket, RootRenderingComponent, vdom, fetch config data) I start the router. It will listen to the event `hashchange`.  \n For example when the URL changes to index.html#p04.",
      "selection": {
        "start": {
          "line": 325,
          "character": 12
        },
        "end": {
          "line": 325,
          "character": 24
        }
      },
      "contents": "#![doc(\n    html_favicon_url = \"https://github.com/LucianoBestia/mem6_game/raw/master/webfolder/mem6/images/icons-16.png\"\n)]\n#![doc(\n    html_logo_url = \"https://github.com/LucianoBestia/mem6_game/raw/master/webfolder/mem6/images/icons-192.png\"\n)]\n// region: lmake_readme insert \"readme.md\"\n//! # unForGetTable  (development name: mem6)\n//!\n//! version: 2020.225.1404  \n//!\n//! mem6 is a simple drinking game to lose memory. It is made primarily for learning the Rust programming language and Wasm/WebAssembly with Virtual Dom Dodrio, WebSocket communication and PWA (Progressive Web App).  \n//!\n//! ## Idea\n//!\n//! Playing the memory game alone is boring.  \n//! Playing it with friends is better. Playing with drinking friends is even better. More friends - more fun.  \n//! I hope you have at least 3 or 4 friends now and all of you are around the same table.  \n//! The first player opens bestia.dev/mem6 and starts the group. Other players scan the QR code and join the same group. Then put all phones on the table near to each other. It will look as a \"big\" board game.  \n//! The game is hyper simple: every player opens 2 cards. If the cards are the same, you drink. If not you don't drink. Then the next player opens 2 cards. And so on...\n//!\n//! ## Rust and Wasm/WebAssembly\n//!\n//! Rust is a pretty new language created by Mozilla for really low level programming.  \n//! It is a step forward from the C language with functionality and features that are best practice today.  \n//! It is pretty hard to learn. Some concepts are so different from other languages it makes it\n//! hard for beginners. Lifetimes are the strangest and most confusing concept.  \n//! The Rust language has been made from the ground up with an ecosystem that makes it productive.  \n//! The language and most of the libraries are Open Source. That is good and bad, but mostly good.  \n//! Rust is the best language today to compile into Wasm/WebAssembly.  \n//! That compiled code works inside a browser directly with the JavaScript engine.  \n//! So finally no need for JavaScript to make cross-platform applications inside browsers.  \n//! I have a lot of hope here.  \n//!\n//! ## Virtual DOM\n//!\n//! Constructing a HTML page with Virtual DOM (vdom) is easier because it is scheduled to render completely on the next tick (animation frame). We can use the term here \"state machine\". The rendering depends only on the state of the data and not on the history of the changes.  \n//! Sometimes is very complex what should change in the UI when some data changes.  \n//! The data can change from many different events and very chaotically (asynchronously).  \n//! It is easier to think how to render the complete DOM for a given state of data.  \n//! The Rust Dodrio library has ticks, time intervals when it does something. If a rendering is scheduled, it will be done on the next tick. If a rendering is not scheduled I believe nothing happens.  \n//! This enables asynchronous changing of data and rendering. They cannot happen theoretically in the\n//! same exact moment. So, no data race here.  \n//! When GameData change and we know it will affect the DOM, then rendering must be scheduled.  \n//! The main component of the Dodrio Virtual Dom is the Root Rendering Component (rrc).  \n//! It is the component that renders the complete user interface (HTML) and contains all the data state.  \n//!\n//! ## GameData\n//!\n//! All the game data state are in this simple struct inside the Root Rendering Component.  \n//!\n//! ## WebSocket communication\n//!\n//! HTML5 has finally bring a true stateful bidirectional communication.  \n//! Most of the programming problems are more easily and effectively solved this way.  \n//! The old unidirectional stateless communication is very good for static html pages, but is terrible for any dynamic page. The WebSocket is very rudimental and often the communication breaks for many different reasons. The programmer must deal with it inside the application.  \n//! I send simple structs text messages in json format between the players. They are all in the WsMsg enum and therefore easy to use by the server and client.  \n//! The WebSocket server is coded especially for this game and recognizes the players string that has a vector of ws_uid to whom send the message.  \n//!\n//! ## WebSockets is not reliable\n//!\n//! Simple messaging is not reliable. On mobiles it is even worse. There is a lot of possibilities that something goes wrong and the message doesn't reach the destination. The protocol has nothing that can be used to deal with reconnections or lost messages.  \n//! That means that I need additional work on the application level - always reply one acknowledgement \"ack\" message.  \n//! Workflow:  \n//!\n//! - sender sends one message to more players (more ws_uid) with one random number msg_id\n//!     push to a vector (msg queue) more items with ws_uid and msg_id\n//!     blocks the continuation of the workflow until receives all ACK from all players\n//!\n//! - receiver on receive send the ACK acknowledge msg with his ws_uid and msg_id\n//!\n//! - the sender receives the ACK and removes one item from the vector\n//!     if there is no more items for that msg_id, the workflow can continue.\n//!     TODO: if after 3 seconds the ACK is not received and error message is shown to the player.\n//!\n//! This is very similar to a message queue...  \n//!\n//! ## gRPC, WebRTC datachannel\n//!\n//! The new shiny protocol gRPC for web communication is great for server-to-server communication. But it is still very limited inside the browser. When it eventually becomes stable I would like to change WebSockets for gRPC.  \n//! The WebRTC datachannel sounds great for peer-to-peer communication. Very probably the players will be all on the same wifi network, this solves all latency issues.  \n//! TODO: try to add this to version 6.  \n//!\n//! ## The game flow\n//!\n//! In a few words:  \n//! Playing player : Status1 - user action - send msg - await for ack msgs - update game data - Status2  \n//! Other players: Status1 - receive WsMessage - send ack msg - update game data - Status2  \n//!\n//! In one moment the game is in a one Game Status for all players.  \n//! One player is the playing player and all others are awaiting.  \n//! The active user then makes an action on the GUI.\n//! This action will eventually change the GameData and the GameStatus. But before that there is communication.  \n//! A message is sent to other players so they can also change their local GameData and GameStatus.  \n//! Because of unreliable networks there must be an acknowledge ack msg to confirm, that the msg is received to continue the game.  \n//! The rendering is scheduled and it will happen shortly (async).  \n//!\n//! ## Futures and Promises, Rust and JavaScript\n//!\n//! JavaScript is all asynchronous. Wasm is nothing else then a shortcut to the JavaScript engine.  \n//! So everything is asynchronous too. This is pretty hard to grasp. Everything is Promises and Futures. Fortunately lately there is async/await for Rust and it is great for dealing with javascript.  \n//! JavaScript does not have a good idea of Rust datatypes. All there is is a generic JSValue type.  \n//! The library `wasm-bindgen` has made a fantastic job of giving Rust the ability to call\n//! anything JavaScript can call, but the way of doing it is sometimes cumbersome.  \n//!\n//! ## Html templating\n//!\n//! In the past I wrote html inside Rust code with the macro `html!` from the `crate typed-html`  \n//! <https://github.com/bodil/typed-html>  \n//! It has also a macro `dodrio !` created exclusively for the dodrio vdom.  \n//! I had two main problems with this approach:  \n//!\n//! 1. Any change to the html required a recompiling. And that is very slow in Rust.  \n//! 2. I could not add new html elements, that the macro don't recognize. I wanted to use SVG. There was not support for that.  \n//!\n//! I reinvented \"html templating\".  \n//! First a graphical designer makes a html/css page that looks nice. No javascript, nothing is dynamic. It is just a graphical template.  \n//! Then I insert in it html comments and \"data-\" attributes that I can later replace in my code.  \n//! The html is not changed graphically because of it. So both the graphical designer and the programmer are still happy.  \n//! In my code I parse the html template as a microXml file. Basically they are the same with small effort. When I find a comment or \"data-\" attribute then the value of the next node is replaced.  \n//! I can replace attributes, strings and entire nodes. And I can insert event for behavior with \"data-t\".  \n//! When developing, the html template is loaded and parsed and a dodrio node is created. That is not very fast. But I can change the html in real time and see it rendered without compiling the Rust code. This is super efficient for development.  \n//! I have in plans to add a Rust code generator, that creates the Rust code for the dodrio node before compile time. In that case nothing is parsed in runtime and I expect great speeds. But the flexibility of easily changing the html template is gone. For every change I must recompile the Rust code.  \n//!\n//! ## Browser console\n//!\n//! At least in modern browsers (Firefox and Chrome) we have the developer tools F12 and there is a\n//! console we can output to. So we can debug what is going on with our Wasm program.\n//! But not on smartphones !! I save the error and log messages in session_storage and this is displayed on the screen.  \n//!\n//! ## Safari on iOS and FullScreen\n//!\n//! Apple is very restrictive and does not allow fullscreen Safari on iPhones.  \n//! The workaround is to `Add to HomeScreen` the webapp.  \n//!\n//! ## PWA (Progressive Web App)\n//!\n//! On both android and iPhone is possible to use PWA.  \n//! To be 100% PWA it must be secured with TLS and must have a service worker.  \n//! I added also the PWA manifest and png images for icons and now the game is a full PWA.  \n//!\n//! **Very important :**\n//! On Android Chrome to `Clear & reset` the cached data of the website you must click on the icon of the URL address (the lock) and choose `Site Settings`.  \n//! Sometimes even that does not work. Than I go in the Menu to Settings - Privacy - Clear browser data and delete all. Very aggressive, but the only way I found that works.  \n//!\n//! ## Modules\n//!\n//! Rust code is splitted into modules. They are not exactly like classes, but can be similar.  \n//! Rust has much more freedom to group code in different ways. So that is best suits the problem.  \n//! I splitted the rendering pages and that into sub-components.  \n//! And then I splitted the User Actions by the Status1 to easy follow the flow of the game.  \n//!\n//! ## State machine\n//!\n//! I try to use the philosophy of \"state machine\" because it is easier to follow.  \n//! All is dependent on the state of the data and not on the chronological events.  \n//! Any event can change the state/data. Then another piece of code will do the rest\n//! based on the state/data. The data can come from different places: user input, fetch from\n//! web, url/hash, local_storage. It doesn't matter. All the data must first go into the state/data.  \n//! Then some other code makes decision based on the state/data.  \n//! The app is divided in 2 ways:\n//!\n//! - visually it is divided in pages and page components\n//! - behaviorally is divided into pages and game_state\n//!\n//! ## Clippy\n//!\n//! Clippy is very useful to teach us how to program Rust in a better way.  \n//! These are not syntax errors, but hints how to do it in a more Rusty way (idiomatic).  \n//! Some lints are problematic and they are explicitly allowed here.\n//!\n//! ## font-size\n//!\n//! Browsers have 2 types of zoom:\n//!\n//! - zoom everything proportionally (I like this.)\n//! - zoom only the text (I hate this: it breaks the layout completely.)\n//!\n//! When the font-size in android is increased (accessibility) it applies somehow also to the browser rendering.  \n//! I have tried many different things, but it looks this cannot be overridden from the css or javascript. Only the user can change this setting in his phone.  \n//!\n//! ## SVG\n//!\n//! This is why I chose to use SVG for my html templates. Svg promises that the user cannot ruin the layout completely. But also SVG has its set of complication small and big.  \n//! It is annoying that SVG must use namespaces for all the elements and subelements.  \n//! I will use percents to define x, y, width and height. Because for the game is only logical to be always full screen.\n//!\n//! ## font-family\n//!\n//! The size of the font depends a lot of the font-family. Every browser show different fonts\n//! even when they call them the same. I need to use a third-party web font. Google seems to\n//! be a good source of free fonts. I choose Roboto. Having them download every time from google is time consuming. So I will download them and host them locally on my website.  \n//! I use the <https://google-webfonts-helper.herokuapp.com> to download fonts.  \n//!\n//! ## favicon.ico\n//!\n//! Crazy stuff. I used the website <https://www.favicon-generator.org/> to generate\n//! all the different imgs, sizes and code. And than add all this into index.html. There is more lines for icons than anything else now. Just crazy world.  \n\n// endregion: lmake_readme insert \"readme.md\"\n\n// needed for dodrio ! macro (typed-html)\n#![recursion_limit = \"512\"]\n// region: Clippy\n#![warn(\n    clippy::all,\n    clippy::restriction,\n    clippy::pedantic,\n    clippy::nursery,\n    clippy::cargo,\n    // variable shadowing is idiomatic to Rust, but unnatural to me.\n    clippy::shadow_reuse,\n    clippy::shadow_same,\n    clippy::shadow_unrelated,\n\n)]\n#![allow(\n    // library from dependencies have this clippy warnings. Not my code.\n    // Why is this bad: It will be more difficult for users to discover the purpose of the crate, \n    // and key information related to it.\n    clippy::cargo_common_metadata,\n    // Why is this bad : This bloats the size of targets, and can lead to confusing error messages when \n    // structs or traits are used interchangeably between different versions of a crate.\n    clippy::multiple_crate_versions,\n    // Why is this bad : As the edition guide says, it is highly unlikely that you work with any possible \n    // version of your dependency, and wildcard dependencies would cause unnecessary \n    // breakage in the ecosystem.\n    clippy::wildcard_dependencies,\n    // Rust is more idiomatic without return statement\n    // Why is this bad : Actually omitting the return keyword is idiomatic Rust code. \n    // Programmers coming from other languages might prefer the expressiveness of return. \n    // It’s possible to miss the last returning statement because the only difference \n    // is a missing ;. Especially in bigger code with multiple return paths having a \n    // return keyword makes it easier to find the corresponding statements.\n    clippy::implicit_return,\n    // I have private function inside a function. Self does not work there.\n    // Why is this bad: Unnecessary repetition. Mixed use of Self and struct name feels inconsistent.\n    clippy::use_self,\n    // Cannot add #[inline] to the start function with #[wasm_bindgen(start)]\n    // because then wasm-pack build --target web returns an error: export run not found \n    // Why is this bad: In general, it is not. Functions can be inlined across crates when that’s profitable \n    // as long as any form of LTO is used. When LTO is disabled, functions that are not #[inline] \n    // cannot be inlined across crates. Certain types of crates might intend for most of the \n    // methods in their public API to be able to be inlined across crates even when LTO is disabled. \n    // For these types of crates, enabling this lint might make sense. It allows the crate to \n    // require all exported methods to be #[inline] by default, and then opt out for specific \n    // methods where this might not make sense.\n    clippy::missing_inline_in_public_items,\n    // Why is this bad: This is only checked against overflow in debug builds. In some applications one wants explicitly checked, wrapping or saturating arithmetic.\n    // clippy::integer_arithmetic,\n    // Why is this bad: For some embedded systems or kernel development, it can be useful to rule out floating-point numbers.\n    clippy::float_arithmetic,\n    // Why is this bad : Doc is good. rustc has a MISSING_DOCS allowed-by-default lint for public members, but has no way to enforce documentation of private items. This lint fixes that.\n    clippy::doc_markdown,\n    // Why is this bad : Splitting the implementation of a type makes the code harder to navigate.\n    clippy::multiple_inherent_impl,\n)]\n// endregion\n\n// region: mod is used only in lib file. All the rest use use crate\nmod ackmsgmod;\nmod divgridcontainermod;\nmod divplayeractionsmod;\nmod fetchmod;\nmod gamedatamod;\nmod rootrenderingcomponentmod;\nmod storagemod;\nmod statusgamedatainitmod;\nmod statusgameovermod;\nmod statusjoinedmod;\nmod status1stcardmod;\nmod status2ndcardmod;\nmod statusdrinkmod;\nmod statustaketurnmod;\nmod statuswaitingackmsgmod;\nmod websocketboilermod;\nmod websocketspecmod;\nmod statusreconnectmod;\nmod routerimplmod;\nmod htmltemplateimplmod;\nmod webdatamod;\nmod webrtcimplmod;\n// endregion\n\n// this are then used in all the mods if I have there use crate::*;\nuse crate::rootrenderingcomponentmod::RootRenderingComponent;\nuse crate::gamedatamod::*;\n\nuse rust_wasm_dodrio_templating::*;\nuse rust_wasm_websys_utils::*;\n//use rust_wasm_websocket::*;\n\n// use unwrap::unwrap;\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen(start)]\n#[allow(clippy::shadow_same)]\n/// To start the Wasm application, wasm_bindgen runs this functions\npub fn wasm_bindgen_start() -> Result<(), JsValue> {\n    // Initialize debugging for when/if something goes wrong.\n    console_error_panic_hook::set_once();\n\n    websysmod::debug_write(&format!(\"wasm app version: {}\", env!(\"CARGO_PKG_VERSION\")));\n\n    // Get the container to render the virtual Dom component.\n    let div_for_virtual_dom = websysmod::get_element_by_id(\"div_for_virtual_dom\");\n\n    // load from storage or get random (and then save)\n    let my_ws_uid = websocketboilermod::load_or_random_ws_uid();\n    let (location_href, href_hash) = websysmod::get_url_and_hash();\n    // Construct a new RootRenderingComponent.\n    let mut rrc = RootRenderingComponent::new(my_ws_uid);\n    rrc.web_data.href = location_href.to_string();\n    rrc.web_data.href_hash = href_hash;\n    // Mount the component to the `<div id=\"div_for_virtual_dom\">`.\n    let vdom_object = dodrio::Vdom::new(&div_for_virtual_dom, rrc);\n    let vdom = vdom_object.weak();\n    // async fetch_response() for gamesmetadata.json\n    fetchmod::fetch_games_metadata_and_update(&location_href, vdom.clone());\n    fetchmod::fetch_videos_and_update(&location_href, vdom.clone());\n    fetchmod::fetch_audio_and_update(&location_href, vdom.clone());\n    // Start the URL router.\n    use rust_wasm_router::routermod::RouterTrait;\n    let router = routerimplmod::Router::new();\n    router.start_router(vdom.clone());\n\n    // Run the component forever. Forget to drop the memory.\n    vdom_object.forget();\n\n    Ok(())\n}\n"
    },
    {
      "file": "mem6/src/routerimplmod.rs",
      "line": 45,
      "description": "### update_local_route_from_root\nThe short_local_route (url hash) `ex. #p04` defines a `local_route`. This is the name of the html template to fetch from the web server. Than it is prepared and saved in html_template sub_templates fields.\nThe data in the struct is prepared, finally we call `vdom.schedule_render();`.",
      "selection": {
        "start": {
          "line": 41,
          "character": 8
        },
        "end": {
          "line": 41,
          "character": 36
        }
      },
      "contents": "//! routerimplmod - A simple `#`-fragment router for dodrio html templating.  \n//! Implementation of Router for this mem6 use case with RootRenderingComponent type\n//! It routes from short_url (the url hash part) to a\n//! html_template file to fetch. The file name is written to rrc.local_route.  \n//! Then fetches the file and stores it in rrc.html_template\n\nuse crate::*;\nuse dodrio::VdomWeak;\n//use unwrap::unwrap;\nuse rust_wasm_router::routermod::{RouterTrait};\n\n/// The struct must be declared near the implementation, not definition of the Trait\npub struct Router {\n    /// local # hash route\n    pub local_route: String,\n}\n\nimpl Router {\n    /// constructor\n    pub fn new() -> Self {\n        // return from constructor\n        Self {\n            local_route: \"\".to_string(),\n        }\n    }\n}\n\nimpl RouterTrait for Router {\n    /// access methods to underlying fields\n    fn get_local_route_from_self(&self) -> &str {\n        //return\n        &self.local_route\n    }\n    /// get rrc.local_route\n    fn get_local_route_from_root(root: &mut dyn dodrio::RootRender) -> &str {\n        let rrc = root.unwrap_mut::<RootRenderingComponent>();\n        &rrc.router_data.local_route\n    }\n\n    /// update local_route with filenames dependent on short_local_route.\n    fn update_local_route_from_root(\n        short_local_route: String,\n        root: &mut dyn dodrio::RootRender,\n        vdom: VdomWeak,\n    ) -> String {\n        let rrc = root.unwrap_mut::<RootRenderingComponent>();\n        // there are 2 entry points: no hash and #p03\n        if short_local_route == \"#p02\" {\n            fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n            rrc.router_data.local_route = \"p02_start_a_group.html\".to_owned();\n        } else if short_local_route.starts_with(\"#p03\") {\n            // entry point for join game\n            rrc.start_websocket(vdom.clone());\n            rrc.game_data.my_player_number = 2;\n            if short_local_route.contains('.') {\n                let gr = Self::get_url_param_in_hash_after_dot(&short_local_route);\n                storagemod::save_group_id_string_to_local_storage(rrc, gr);\n            } else {\n                storagemod::load_group_id_string(rrc);\n            }\n            rrc.router_data.local_route = \"p03_join_a_group.html\".to_owned();\n        } else if short_local_route == \"#p04\" {\n            statusjoinedmod::on_load_joined(rrc);\n            rrc.router_data.local_route = \"p04_wait_to_start.html\".to_owned();\n        } else if short_local_route == \"#p05\" {\n            rrc.router_data.local_route = \"p05_choose_game.html\".to_owned();\n        } else if short_local_route == \"#p06\" {\n            rrc.router_data.local_route = \"p06_drink.html\".to_owned();\n        } else if short_local_route == \"#p07\" {\n            rrc.router_data.local_route = \"p07_do_not_drink.html\".to_owned();\n        } else if short_local_route == \"#p08\" {\n            rrc.router_data.local_route = \"p08_instructions.html\".to_owned();\n        } else if short_local_route == \"#p11\" {\n            rrc.router_data.local_route = \"p11_gameboard.html\".to_owned();\n        } else if short_local_route == \"#p21\" {\n            rrc.router_data.local_route = \"p21_menu.html\".to_owned();\n        } else if short_local_route == \"#p31\" {\n            rrc.router_data.local_route = \"p31_debug_text.html\".to_owned();\n        } else if short_local_route == \"#p41\" {\n            // entry point for webrtc chat\n            rrc.start_websocket(vdom.clone());\n            rrc.router_data.local_route = \"p41_webrtc.html\".to_owned();\n        } else {\n            // main entry point\n            rrc.router_data.local_route = \"p01_start.html\".to_owned();\n        }\n        // return\n        rrc.router_data.local_route.to_string()\n    }\n\n    /// update html_template and extract and saves html_sub_templates\n    #[allow(clippy::integer_arithmetic)]\n    #[allow(clippy::indexing_slicing)]\n    fn update_html_template_and_sub_templates(\n        resp_body_text: String,\n    ) -> Box<dyn Fn(&mut dyn dodrio::RootRender) + 'static> {\n        // Callback fired whenever the URL hash fragment changes.\n        // Keeps the rrc.router_data.local_route in sync with the `#` fragment.\n        Box::new(move |root| {\n            let rrc = root.unwrap_mut::<RootRenderingComponent>();\n            htmltemplateimplmod::update_html_template_and_sub_templates(rrc, &resp_body_text);\n        })\n    }\n}\n"
    },
    {
      "file": "mem6/src/rootrenderingcomponentmod.rs",
      "line": 51,
      "description": "### render()\nThis is the only method that is called when the rendering is scheduled. \nIt is defined in the crate `dodrio: the vdom library`.   \nFrom here we then call functions to render different UI depending on the data state. ",
      "selection": {
        "start": {
          "line": 51,
          "character": 8
        },
        "end": {
          "line": 51,
          "character": 14
        }
      },
      "contents": "// rootrenderingcomponentmod.rs\n//! renders the web page\n\n// region: use, const\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\n\nuse unwrap::unwrap;\nuse dodrio::{Node, Render, RenderContext, VdomWeak};\n\n// endregion\n\n/// Root Rendering Component has all\n/// the data needed for play logic and rendering\npub struct RootRenderingComponent {\n    /// data for web and communication\n    pub web_data: webdatamod::WebData,\n    /// game data will be inside of Root\n    pub game_data: gamedatamod::GameData,\n    /// router data\n    pub router_data: routerimplmod::Router,\n}\n\n/// impl\nimpl RootRenderingComponent {\n    /// Construct a new `RootRenderingComponent` at the beginning only once.\n    pub fn new(my_ws_uid: usize) -> Self {\n        let game_data = gamedatamod::GameData::new(my_ws_uid);\n        let msg_receivers_json = game_data.prepare_json_msg_receivers();\n        let web_data = webdatamod::WebData::new(my_ws_uid, msg_receivers_json);\n        let router_data = routerimplmod::Router::new();\n\n        RootRenderingComponent {\n            web_data,\n            game_data,\n            router_data,\n        }\n    }\n\n    /// start websocket and store in web_data and web_rtc_data\n    pub fn start_websocket(&mut self, vdom: VdomWeak) {\n        self.web_data.start_websocket(vdom);\n        self.web_data.web_rtc_data.rtc_ws = self.web_data.websocket_data.ws.clone();\n    }\n}\n\n///`Render` trait implementation on RootRenderingComponent struct\n/// It is called for every Dodrio animation frame to render the vdom.\n/// Only when render is scheduled after some change id the game data.\nimpl<'a> Render<'a> for RootRenderingComponent {\n    fn render(&self, cx: &mut RenderContext<'a>) -> Node<'a> {\n        // let bump = cx.bump;\n        // return\n        // html fragment from html_template defined in # local_route\n        if self.web_data.html_template.is_empty() {\n            htmltemplatemod::empty_div(cx)\n        } else {\n            // i must add use crate::htmltemplatemod::HtmlTemplating;\n            // to allow this trait to be used here on self\n            unwrap!(self.render_template(\n                cx,\n                &self.web_data.html_template,\n                htmltemplatemod::HtmlOrSvg::Html,\n            ))\n        }\n    }\n}\n"
    },
    {
      "file": "mem6/Cargo.toml",
      "line": 29,
      "description": "### dodrio\n<github.com/fitzgen/dodrio> is a virtual DOM library for Rust+Wasm.  \nThe vdom approach aims to make it easier for the developer to think about the dom changes. The classic approach is to react to en event and then programatically modify the dom. The problem is that it becomes quickly very complex. It is difficult to think (and test) an outcome after a long sequence of events.  \nIt is easier to think about the dom as a \"state machine\". The virtual dom is rendered from scratch every single time. The rendering depends only on the `state data` that is now in the data model (a struct called RootRenderingComponent). So changing this struct (data model) and scheduling the rendering, will result in a different vdom. No other complications around that. Pure simple. Easy to think, easy to test.     \nThen the original dom is modified to resemble the vdom. Modifying the dom is slow. To make it efficient, there is some smart caching and diff-ing in the library, to make the number of changes as small and efficient as possible.  \nIn this way we have a clear separation between data (RootRenderingComponent) and UI (code to render html virtual dom).  ",
      "contents": "[package]\nname = \"mem6\"\nversion = \"2020.422.1045\"\nauthors = [\"Luciano Furlan <Luciano.Bestia@gmail.com>\"]\nedition = \"2018\"\ndescription = \"Learning Rust Wasm/WebAssembly with Virtual Dom Dodrio\"\nrepository = \"https://github.com/LucianoBestia/mem6_game\"\nreadme = \"README.md\"\nlicense = \"MIT\"\nkeywords = [\"wasm\",\"dodrio\",\"virtual dom\"]\ncategories = [\"game\",\"learning\"]\npublish = false\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\n# my dependencies\nrust_wasm_websys_utils = { path = \"../rust_wasm_websys_utils\" }\nrust_wasm_router = { path = \"../rust_wasm_router\" }\nrust_wasm_dodrio_templating = { path = \"../rust_wasm_dodrio_templating\" }\nrust_wasm_websocket = { path = \"../rust_wasm_websocket\" }\nrust_wasm_webrtc = { path = \"../rust_wasm_webrtc\" }\n#qrcode53bytes = { path = \"../../qrcode53bytes\" }\nqrcode53bytes =\"1.0.0\"\n\n# other dependencies\nunwrap = \"1.2.1\"\n# dodrio = \"0.1.0\"\n# dodrio =  { git = \"https://github.com/fitzgen/dodrio\", branch = \"master\" }\ndodrio = {path = \"../../dodrio\"}\nwasm-bindgen = { version = \"0.2.58\", features = [\"serde-serialize\"] }\nconsole_error_panic_hook = \"0.1.6\"\n#newer version of rand do not have smallring\nrand = { version = \"0.7.3\", features = [\"wasm-bindgen\",\"small_rng\"] }\njs-sys = \"0.3\"\nserde =\"1.0.104\"\nserde_derive = \"1.0.104\"\nserde_json = \"1.0\"\n#udep futures = \"0.3.1\"\n# newer futures have unstable .await\nwasm-bindgen-futures = \"0.4.8\"\n#log = \"0.4.8\"\nstrum = \"0.17.1\"\nstrum_macros = \"0.17.1\"\nconv = \"0.3.3\"\ngloo-timers = {version=\"0.2.0\", features=[\"futures\"]}\nreader_for_microxml = \"1.0.4\"\n#udep mopa = \"0.2.2\"\n\n[dependencies.web-sys]\nversion = \"0.3.33\"\nfeatures = [\n  \"AbortController\",\n  \"console\",\n  \"CssStyleDeclaration\",\n  \"Document\",\n  \"Element\",\n  \"ErrorEvent\",\n  \"Event\",\n  \"EventListener\",\n  \"EventTarget\",\n  \"FormData\",\n  \"Headers\",\n  \"History\",\n  \"HtmlElement\",\n  \"HtmlFontElement\",\n  \"HtmlFormElement\",\n  \"HtmlHtmlElement\",\n  \"HtmlInputElement\",\n  \"HtmlImageElement\",\n  \"HtmlAudioElement\",\n  \"HtmlMediaElement\",\n  \"HtmlSpanElement\",\n  \"KeyboardEvent\",\n  \"Location\",\n  \"MediaQueryList\",\n  \"MouseEvent\",\n  \"Navigator\",\n  \"Node\",\n  \"ReferrerPolicy\",\n  \"Request\",\n  \"RequestCache\",\n  \"RequestCredentials\",\n  \"RequestInit\",\n  \"RequestMode\",\n  \"RequestRedirect\",\n  \"Response\",\n  \"RtcConfiguration\",\n  \"RtcDataChannelInit\",\n  \"RtcDataChannel\",\n  \"RtcDataChannelState\",\n  \"RtcSessionDescription\",\n  \"RtcSessionDescriptionInit\",\n  \"RtcIceCandidate\",\n  \"RtcIceCandidateInit\",\n  \"RtcPeerConnectionIceEvent\",\n  \"RtcPeerConnection\",\n  \"RtcSdpType\",\n  \"Screen\",\n  \"Storage\",\n  \"WebSocket\",\n  \"Window\",\n]\n\n[dev-dependencies]\nwasm-bindgen-test = \"0.3.8\"\n\n# Rust does not have yet 2020-04-20 profiles on webspave projects\n# I can put it only on the workspace alone.\n#[profile.release]\n#panic = \"abort\"\n"
    },
    {
      "file": "mem6/Cargo.toml",
      "line": 31,
      "description": "### crates.io or github or path\nIf the newest version of dodrio on crates.io is not actual enought,  \nin cargo.toml we can depend on github or local path also.  \nSo we can follow the codeflow and change something if we need to.  ",
      "selection": {
        "start": {
          "line": 29,
          "character": 1
        },
        "end": {
          "line": 31,
          "character": 33
        }
      },
      "contents": "[package]\nname = \"mem6\"\nversion = \"2020.422.1045\"\nauthors = [\"Luciano Furlan <Luciano.Bestia@gmail.com>\"]\nedition = \"2018\"\ndescription = \"Learning Rust Wasm/WebAssembly with Virtual Dom Dodrio\"\nrepository = \"https://github.com/LucianoBestia/mem6_game\"\nreadme = \"README.md\"\nlicense = \"MIT\"\nkeywords = [\"wasm\",\"dodrio\",\"virtual dom\"]\ncategories = [\"game\",\"learning\"]\npublish = false\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\n# my dependencies\nrust_wasm_websys_utils = { path = \"../rust_wasm_websys_utils\" }\nrust_wasm_router = { path = \"../rust_wasm_router\" }\nrust_wasm_dodrio_templating = { path = \"../rust_wasm_dodrio_templating\" }\nrust_wasm_websocket = { path = \"../rust_wasm_websocket\" }\nrust_wasm_webrtc = { path = \"../rust_wasm_webrtc\" }\n#qrcode53bytes = { path = \"../../qrcode53bytes\" }\nqrcode53bytes =\"1.0.0\"\n\n# other dependencies\nunwrap = \"1.2.1\"\n# dodrio = \"0.1.0\"\n# dodrio =  { git = \"https://github.com/fitzgen/dodrio\", branch = \"master\" }\ndodrio = {path = \"../../dodrio\"}\nwasm-bindgen = { version = \"0.2.58\", features = [\"serde-serialize\"] }\nconsole_error_panic_hook = \"0.1.6\"\n#newer version of rand do not have smallring\nrand = { version = \"0.7.3\", features = [\"wasm-bindgen\",\"small_rng\"] }\njs-sys = \"0.3\"\nserde =\"1.0.104\"\nserde_derive = \"1.0.104\"\nserde_json = \"1.0\"\n#udep futures = \"0.3.1\"\n# newer futures have unstable .await\nwasm-bindgen-futures = \"0.4.8\"\n#log = \"0.4.8\"\nstrum = \"0.17.1\"\nstrum_macros = \"0.17.1\"\nconv = \"0.3.3\"\ngloo-timers = {version=\"0.2.0\", features=[\"futures\"]}\nreader_for_microxml = \"1.0.4\"\n#udep mopa = \"0.2.2\"\n\n[dependencies.web-sys]\nversion = \"0.3.33\"\nfeatures = [\n  \"AbortController\",\n  \"console\",\n  \"CssStyleDeclaration\",\n  \"Document\",\n  \"Element\",\n  \"ErrorEvent\",\n  \"Event\",\n  \"EventListener\",\n  \"EventTarget\",\n  \"FormData\",\n  \"Headers\",\n  \"History\",\n  \"HtmlElement\",\n  \"HtmlFontElement\",\n  \"HtmlFormElement\",\n  \"HtmlHtmlElement\",\n  \"HtmlInputElement\",\n  \"HtmlImageElement\",\n  \"HtmlAudioElement\",\n  \"HtmlMediaElement\",\n  \"HtmlSpanElement\",\n  \"KeyboardEvent\",\n  \"Location\",\n  \"MediaQueryList\",\n  \"MouseEvent\",\n  \"Navigator\",\n  \"Node\",\n  \"ReferrerPolicy\",\n  \"Request\",\n  \"RequestCache\",\n  \"RequestCredentials\",\n  \"RequestInit\",\n  \"RequestMode\",\n  \"RequestRedirect\",\n  \"Response\",\n  \"RtcConfiguration\",\n  \"RtcDataChannelInit\",\n  \"RtcDataChannel\",\n  \"RtcDataChannelState\",\n  \"RtcSessionDescription\",\n  \"RtcSessionDescriptionInit\",\n  \"RtcIceCandidate\",\n  \"RtcIceCandidateInit\",\n  \"RtcPeerConnectionIceEvent\",\n  \"RtcPeerConnection\",\n  \"RtcSdpType\",\n  \"Screen\",\n  \"Storage\",\n  \"WebSocket\",\n  \"Window\",\n]\n\n[dev-dependencies]\nwasm-bindgen-test = \"0.3.8\"\n\n# Rust does not have yet 2020-04-20 profiles on webspave projects\n# I can put it only on the workspace alone.\n#[profile.release]\n#panic = \"abort\"\n"
    },
    {
      "file": "mem6/src/rootrenderingcomponentmod.rs",
      "line": 22,
      "description": "### data model\nThe struct RootRenderingComponent contains ALL the data that is needed to render the UI. I separated the data in sub-structs, just for clarity.  \nWhen an event occures, we just change the data and then schedule the rendering.  \nInside the event code we don't bother about the dom change !    \nWe have a clear separation between data and User-Interface because of that.  \n",
      "selection": {
        "start": {
          "line": 13,
          "character": 1
        },
        "end": {
          "line": 22,
          "character": 2
        }
      },
      "contents": "// rootrenderingcomponentmod.rs\n//! renders the web page\n\n// region: use, const\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\n\nuse unwrap::unwrap;\nuse dodrio::{Node, Render, RenderContext, VdomWeak};\n\n// endregion\n\n/// Root Rendering Component has all\n/// the data needed for play logic and rendering\npub struct RootRenderingComponent {\n    /// data for web and communication\n    pub web_data: webdatamod::WebData,\n    /// game data will be inside of Root\n    pub game_data: gamedatamod::GameData,\n    /// router data\n    pub router_data: routerimplmod::Router,\n}\n\n/// impl\nimpl RootRenderingComponent {\n    /// Construct a new `RootRenderingComponent` at the beginning only once.\n    pub fn new(my_ws_uid: usize) -> Self {\n        let game_data = gamedatamod::GameData::new(my_ws_uid);\n        let msg_receivers_json = game_data.prepare_json_msg_receivers();\n        let web_data = webdatamod::WebData::new(my_ws_uid, msg_receivers_json);\n        let router_data = routerimplmod::Router::new();\n\n        RootRenderingComponent {\n            web_data,\n            game_data,\n            router_data,\n        }\n    }\n\n    /// start websocket and store in web_data and web_rtc_data\n    pub fn start_websocket(&mut self, vdom: VdomWeak) {\n        self.web_data.start_websocket(vdom);\n        self.web_data.web_rtc_data.rtc_ws = self.web_data.websocket_data.ws.clone();\n    }\n}\n\n///`Render` trait implementation on RootRenderingComponent struct\n/// It is called for every Dodrio animation frame to render the vdom.\n/// Only when render is scheduled after some change id the game data.\nimpl<'a> Render<'a> for RootRenderingComponent {\n    fn render(&self, cx: &mut RenderContext<'a>) -> Node<'a> {\n        // let bump = cx.bump;\n        // return\n        // html fragment from html_template defined in # local_route\n        if self.web_data.html_template.is_empty() {\n            htmltemplatemod::empty_div(cx)\n        } else {\n            // i must add use crate::htmltemplatemod::HtmlTemplating;\n            // to allow this trait to be used here on self\n            unwrap!(self.render_template(\n                cx,\n                &self.web_data.html_template,\n                htmltemplatemod::HtmlOrSvg::Html,\n            ))\n        }\n    }\n}\n"
    },
    {
      "file": "mem6/src/rootrenderingcomponentmod.rs",
      "line": 64,
      "description": "### render_template ()\nThe function `render_template` will read the html of the template and create dodrio vdom elements in the same sort order. Before some elements/attributes there are comments or `data-` attributes that change the next element/attribute. These are not visible, so the template is still a regular html document that the graphical designer can look and modify statically without dinamic elements. The programmer than adds/modify the `replace elements or attributes`.  \nThe result is the `dodrio:Node` that represents the vdom.  \nThe vdom library then diffs and modify the real dom.  ",
      "selection": {
        "start": {
          "line": 58,
          "character": 1
        },
        "end": {
          "line": 64,
          "character": 15
        }
      },
      "contents": "// rootrenderingcomponentmod.rs\n//! renders the web page\n\n// region: use, const\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\n\nuse unwrap::unwrap;\nuse dodrio::{Node, Render, RenderContext, VdomWeak};\n\n// endregion\n\n/// Root Rendering Component has all\n/// the data needed for play logic and rendering\npub struct RootRenderingComponent {\n    /// data for web and communication\n    pub web_data: webdatamod::WebData,\n    /// game data will be inside of Root\n    pub game_data: gamedatamod::GameData,\n    /// router data\n    pub router_data: routerimplmod::Router,\n}\n\n/// impl\nimpl RootRenderingComponent {\n    /// Construct a new `RootRenderingComponent` at the beginning only once.\n    pub fn new(my_ws_uid: usize) -> Self {\n        let game_data = gamedatamod::GameData::new(my_ws_uid);\n        let msg_receivers_json = game_data.prepare_json_msg_receivers();\n        let web_data = webdatamod::WebData::new(my_ws_uid, msg_receivers_json);\n        let router_data = routerimplmod::Router::new();\n\n        RootRenderingComponent {\n            web_data,\n            game_data,\n            router_data,\n        }\n    }\n\n    /// start websocket and store in web_data and web_rtc_data\n    pub fn start_websocket(&mut self, vdom: VdomWeak) {\n        self.web_data.start_websocket(vdom);\n        self.web_data.web_rtc_data.rtc_ws = self.web_data.websocket_data.ws.clone();\n    }\n}\n\n///`Render` trait implementation on RootRenderingComponent struct\n/// It is called for every Dodrio animation frame to render the vdom.\n/// Only when render is scheduled after some change id the game data.\nimpl<'a> Render<'a> for RootRenderingComponent {\n    fn render(&self, cx: &mut RenderContext<'a>) -> Node<'a> {\n        // let bump = cx.bump;\n        // return\n        // html fragment from html_template defined in # local_route\n        if self.web_data.html_template.is_empty() {\n            htmltemplatemod::empty_div(cx)\n        } else {\n            // i must add use crate::htmltemplatemod::HtmlTemplating;\n            // to allow this trait to be used here on self\n            unwrap!(self.render_template(\n                cx,\n                &self.web_data.html_template,\n                htmltemplatemod::HtmlOrSvg::Html,\n            ))\n        }\n    }\n}\n"
    },
    {
      "file": "webfolder/mem6/p05_choose_game.html",
      "line": 23,
      "description": "### templating variables\nHere we can see a html template with the replace `comments` ex. <!--t=game_name--> and `data- attributes` ex. `data-on-click=\"game_type_left_onclick\"`.",
      "selection": {
        "start": {
          "line": 17,
          "character": 24
        },
        "end": {
          "line": 17,
          "character": 62
        }
      },
      "contents": "<html>\n\n<head>\n  <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <title>rust_wasm_dodrio_templating</title>\n  <link rel=\"stylesheet\" href=\"css/mem6.css\">\n</head>\n\n<body>\n  <svg height=\"100%\" width=\"100%\">\n    <text x=\"50%\" y=\"15%\" class=\"h1 clickable orange bold\"\n          data-on-click=\"open_youtube\">unForGetTable</text>\n\n    <text x=\"50%\" y=\"50%\" class=\"h6\">Choose a type of game</text>\n    <rect class=\"rounded green clickable\" x=\"5%\" y=\"52.5%\" width=\"10%\"\n          height=\"10%\" data-on-click=\"game_type_left_onclick\" />\n    <text x=\"10%\" y=\"58%\" class=\"h2\">&lt;</text>\n    <rect class=\"rounded green clickable\" x=\"85%\" y=\"52.5%\" width=\"10%\"\n          height=\"10%\" data-on-click=\"game_type_right_onclick\" />\n    <text x=\"90%\" y=\"58%\" class=\"h2\">&gt;</text>\n    <text x=\"50%\" y=\"57.5%\" class=\"h2\">\n      <!--t=game_name-->alphabet</text>\n\n    <rect class=\"btn\" y=\"82%\" data-on-click=\"start_game_onclick\"></rect>\n    <text x=\"50%\" y=\"87.5%\" class=\"h3\">Start to unForGet </text>\n\n    <image class=\"clickable\" x=\"0%\" y=\"95%\" height=\"5%\" width=\"10%\"\n           data-on-click=\"open_menu\" href=\"images/hamburger.png\" />\n  </svg>\n</body>\n\n</html>"
    },
    {
      "file": "mem6/src/htmltemplateimplmod.rs",
      "line": 41,
      "description": "### call_fn_string\nThis fn will replace the next text element after <!--t=fn_name--> or the next attribute value after `data-t-style=\"fn_name\"` with a string.",
      "selection": {
        "start": {
          "line": 41,
          "character": 8
        },
        "end": {
          "line": 41,
          "character": 22
        }
      },
      "contents": "//! htmltemplateimplmod  \n\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\nuse rust_wasm_webrtc::webrtcmod::WebRtcTrait;\n\nuse unwrap::unwrap;\n//use wasm_bindgen::{JsCast};\nuse dodrio::{\n    Node, RenderContext, RootRender,\n    bumpalo::{self},\n    builder::{ElementBuilder, text},\n    VdomWeak,\n};\nuse web_sys::{Event};\n\nimpl htmltemplatemod::HtmlTemplating for RootRenderingComponent {\n    /// html_templating boolean id the next node is rendered or not\n    fn call_fn_boolean(&self, fn_name: &str) -> bool {\n        // websysmod::debug_write(&format!(\"call_fn_boolean: {}\", &fn_name));\n        match fn_name {\n            \"is_first_player\" => self.game_data.my_player_number == 1,\n            \"player_joined\" => self.game_data.players.len() > 1,\n            \"sounds_and_labels\" => self.game_data.sounds_and_labels,\n            \"rtc_is_data_channel_open\" => self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            \"is_not_rtc_data_channel_open\" => !self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_boolean: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                true\n            }\n        }\n    }\n\n    /// html_templating functions that return a String\n    #[allow(\n        clippy::needless_return,\n        clippy::integer_arithmetic,\n        clippy::indexing_slicing\n    )]\n    fn call_fn_string(&self, fn_name: &str) -> String {\n        // websysmod::debug_write(&format!(\"call_fn_string: {}\", &fn_name));\n        match fn_name {\n            \"my_nickname\" => self.game_data.my_nickname.to_owned(),\n            \"blink_or_not_nickname\" => storagemod::blink_or_not_nickname(self),\n            \"blink_or_not_group_id\" => blink_or_not_group_id(self),\n            \"my_ws_uid\" => format!(\"{}\", self.web_data.my_ws_uid),\n            \"receiver_ws_uid\" => format!(\"{}\", self.web_data.web_rtc_data.rtc_receiver_ws_uid),\n            \"players_count\" => format!(\"{} \", self.game_data.players.len() - 1),\n            \"game_name\" => self.game_data.game_name.to_string(),\n            \"group_id\" => self.game_data.group_id.to_string(),\n            \"url_to_join\" => format!(\"bestia.dev/mem6/#p03.{}\", self.web_data.my_ws_uid),\n            \"cargo_pkg_version\" => env!(\"CARGO_PKG_VERSION\").to_string(),\n            \"debug_text\" => websysmod::get_debug_text(),\n            \"game_status\" => self.game_data.game_status.as_ref().to_string(),\n            \"my_player_number\" => self.game_data.my_player_number.to_string(),\n            \"gameboard_btn\" => {\n                // different class depend on status\n                \"btn\".to_owned()\n            }\n            \"card_moniker_first\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_1st_card().card_number]\n                    .to_string();\n            }\n            \"card_moniker_second\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_2nd_card().card_number]\n                    .to_string();\n            }\n            \"my_points\" => {\n                return format!(\"{} \", self.game_data.my_player().points,);\n            }\n            \"player_turn_nickname\" => {\n                //websysmod::debug_write(\"player_turn_nickname\");\n                return self.game_data.player_turn_now().nickname.to_string();\n            }\n            \"sounds_and_labels\" => {\n                return if self.game_data.sounds_and_labels == true {\n                    \"sounds and labels ON\".to_string()\n                } else {\n                    \"sounds and labels OFF\".to_string()\n                };\n            }\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_string: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                x\n            }\n        }\n    }\n\n    /// return a closure for the listener.\n    #[allow(clippy::too_many_lines, clippy::type_complexity)]\n    fn call_fn_listener(\n        &self,\n        fn_name: String,\n    ) -> Box<dyn Fn(&mut dyn RootRender, VdomWeak, Event) + 'static> {\n        Box::new(move |root, vdom, event| {\n            let fn_name = fn_name.clone();\n            let fn_name = fn_name.as_str();\n            let rrc = root.unwrap_mut::<RootRenderingComponent>();\n            //websysmod::debug_write(&format!(\"call_fn_listener: {}\", &fn_name));\n            match fn_name {\n                \"nickname_onkeyup\" => {\n                    storagemod::nickname_onkeyup(rrc, event);\n                }\n                \"group_id_onkeyup\" => {\n                    storagemod::group_id_onkeyup(rrc, event);\n                }\n                \"open_youtube\" => {\n                    // randomly choose a link from rrc.videos\n                    let num = websysmod::get_random(0, rrc.game_data.videos.len());\n                    #[allow(clippy::indexing_slicing)]\n                    // cannot panic:the num is 0..video.len\n                    websysmod::open_new_tab(&format!(\n                        \"https://www.youtube.com/watch?v={}\",\n                        rrc.game_data.videos[num]\n                    ));\n                }\n                \"open_menu\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p21\");\n                }\n                \"sounds_and_labels\" => {\n                    // toggle sound and label on/off\n                    websysmod::debug_write(&format!(\"on click sounds and labels: {}\", \"\"));\n                    if rrc.game_data.sounds_and_labels == true {\n                        rrc.game_data.sounds_and_labels = false;\n                    } else {\n                        rrc.game_data.sounds_and_labels = true;\n                    }\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgSoundsAndLabels {\n                                sounds_and_labels: rrc.game_data.sounds_and_labels,\n                            },\n                        });\n                    vdom.schedule_render();\n                }\n                \"back_to_game\" => {\n                    let h = unwrap!(websysmod::window().history());\n                    let _x = h.back();\n                }\n                \"open_instructions\" => {\n                    websysmod::open_new_tab(\"#p08\");\n                }\n                \"debug_log\" => {\n                    websysmod::open_new_tab(\"#p31\");\n                }\n                \"webrtc\" => {\n                    open_new_local_page(\"#p41\");\n                }\n                \"web_rtc_receiver_ws_uid_onkeyup\" => {\n                    webrtcimplmod::web_rtc_receiver_ws_uid_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_start\" => {\n                    rrc.web_data.web_rtc_data\n                        .web_rtc_start(vdom, unwrap!(rrc.web_data.websocket_data.ws.clone()));\n                }\n                \"web_rtc_chat_text_onkeyup\" => {\n                    webrtcimplmod::web_rtc_chat_text_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_send_chat\" => {\n                    rrc.web_data.web_rtc_data.web_rtc_send_chat(vdom);\n                }\n                \"start_a_group_onclick\" => {\n                    // entry point for the game\n                    rrc.start_websocket(vdom);\n                    open_new_local_page(\"#p02\");\n                }\n                \"restart_game\" => {\n                    // send a msg to others to open #p04\n                    statusgameovermod::on_msg_play_again(rrc);\n                    open_new_local_page(\"#p02\");\n                }\n                \"join_a_group_onclick\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p03\");\n                }\n                \"choose_a_game_onclick\" => {\n                    open_new_local_page(\"#p05\");\n                }\n                \"start_game_onclick\" => {\n                    statusgamedatainitmod::on_click_start_game(rrc);\n                    // async fetch all imgs and put them in service worker cache\n                    fetchmod::fetch_all_img_for_cache_request(rrc);\n                    // websysmod::debug_write(&format!(\"start_game_onclick players: {:?}\",rrc.game_data.players));\n                    open_new_local_page(\"#p11\");\n                }\n                \"game_type_right_onclick\" => {\n                    game_type_right_onclick(rrc, vdom);\n                }\n                \"game_type_left_onclick\" => {\n                    game_type_left_onclick(rrc, vdom);\n                }\n                \"join_group_on_click\" => {\n                    open_new_local_page(\"#p04\");\n                }\n                \"drink_end\" => {\n                    // send a msg to end drinking to all players\n\n                    websysmod::debug_write(&format!(\"MsgDrinkEnd send{}\", \"\"));\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgDrinkEnd {},\n                        });\n                    // if all the cards are permanently up, this is the end of the game\n                    // websysmod::debug_write(\"if is_all_permanently(rrc)\");\n                    if status2ndcardmod::is_all_permanently(rrc) {\n                        websysmod::debug_write(\"yes\");\n                        statusgameovermod::on_msg_game_over(rrc);\n                        // send message\n                        rrc.web_data\n                            .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                                msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                                msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                                msg_data: gamedatamod::WsMessageGameData::MsgGameOver {},\n                            });\n                    } else {\n                        statustaketurnmod::on_click_take_turn(rrc, vdom.clone());\n                    }\n                    // end the drink page\n                    open_new_local_page(\"#p11\");\n                }\n                \"p06_load_image\" => {\n                    //websysmod::debug_write(\"p06_load_image\");\n                    statusdrinkmod::play_sound_for_drink(rrc);\n                }\n                \"play_again\" => {\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgPlayAgain {},\n                        });\n                    rrc.game_data.reset_for_play_again();\n                    open_new_local_page(\"#p05\");\n                }\n                \"on_click_img_status1st\" => {\n                    status1stcardmod::on_click_img_status1st(root, vdom.clone(), &event);\n                }\n                \"on_click_img_status2nd\" => {\n                    status2ndcardmod::on_click_img_status2nd(root, vdom.clone(), &event);\n                }\n                \"hide_big_img\" => {\n                    hide_big_img();\n                }\n                _ => {\n                    let x = format!(\"Error: Unrecognized call_fn_listener: \\\"{}\\\"\", fn_name);\n                    websysmod::debug_write(&x);\n                }\n            }\n        })\n    }\n\n    /// html_templating functions that return a Node\n    #[allow(clippy::needless_return)]\n    fn call_fn_node<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Node<'a> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_container\" => {\n                // what is the game_status now?\n                // websysmod::debug_write(&format!(\"game status: {}\", self.game_data.game_status));\n                let max_grid_size = divgridcontainermod::max_grid_size(self);\n                return divgridcontainermod::div_grid_container(self, cx, &max_grid_size);\n            }\n            \"div_player_action\" => {\n                let node = divplayeractionsmod::div_player_actions_from_game_status(self, cx);\n                return node;\n            }\n            \"svg_qrcode\" => {\n                return svg_qrcode_to_node(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return node;\n            }\n        }\n    }\n\n    /// html_templating functions that return a vector of Nodes\n    #[allow(clippy::needless_return)]\n    fn call_fn_vec_nodes<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Vec<Node<'a>> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_all_items\" => {\n                return divgridcontainermod::div_grid_all_items(self, cx);\n            }\n            \"web_rtc_div_messages\" => {\n                return webrtcimplmod::web_rtc_div_messages(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return vec![node];\n            }\n        }\n    }\n}\n\n/// qrcode svg\npub fn svg_qrcode_to_node<'a>(\n    rrc: &RootRenderingComponent,\n    cx: &mut RenderContext<'a>,\n) -> Node<'a> {\n    let link = format!(\"https://bestia.dev/mem6/#p03.{}\", rrc.web_data.my_ws_uid);\n    let qr = unwrap!(qrcode53bytes::Qr::new(&link));\n    let svg_template = qrcode53bytes::SvgDodrioRenderer::new(222, 222).render(&qr);\n    // i added use crate::htmltemplatemod::HtmlTemplating; to make the function render_template in scope.\n    unwrap!(rrc.render_template(cx, &svg_template, htmltemplatemod::HtmlOrSvg::Svg))\n}\n\n/// the arrow to the right\npub fn game_type_right_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.last()).name.to_string();\n    for x in gmd {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// left arrow button\npub fn game_type_left_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.first()).name.to_string();\n    for x in gmd.iter().rev() {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// fn open new local page with #\n/// does not push to history\npub fn open_new_local_page(hash: &str) {\n    // I want to put the first url in history.\n    // These are opened from outside my app and I cannot manage that differently.\n    // There are 2 of them:\n    // 1. if the players starts without hash\n    // 2. if the player scanned the qrcode and opened the p3 with group_id\n    // For links opened inside the app, I can call the open with or without history.\n    // For example for menu p21 I want to have a back button.\n    let (_old_location_href, old_href_hash) = websysmod::get_url_and_hash();\n    if old_href_hash.is_empty() || old_href_hash.starts_with(\"#p03.\") {\n        websysmod::open_new_local_page_push_to_history(hash)\n    } else {\n        let _x = websysmod::window().location().replace(hash);\n    }\n}\n\n/// if there is already a group_id don't blink\npub fn blink_or_not_group_id(rrc: &RootRenderingComponent) -> String {\n    if rrc.game_data.group_id == 0 {\n        \"blink\".to_owned()\n    } else {\n        \"\".to_owned()\n    }\n}\n\n/// hide big img\npub fn hide_big_img() {\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    let _x = img_html_element.style().set_property(\"display\", \"none\");\n}\n\n/// visible big img\npub fn visible_big_img(img_file_name: &str) {\n    websysmod::debug_write(img_file_name);\n    //change png in jpg for big img\n    let img_file_name = img_file_name.replace(\".png\", \".jpg\");\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    img_html_element.set_src(&img_file_name);\n    let _x = img_html_element.style().set_property(\"display\", \"initial\");\n}\n\n/// update html_template and extract and saves html_sub_templates\n#[allow(clippy::integer_arithmetic)]\n#[allow(clippy::indexing_slicing)]\npub fn update_html_template_and_sub_templates(rrc:&mut RootRenderingComponent, resp_body_text: &str,)  {\n        // only the html inside the <body> </body>\n        let mut tm = between_body_tag(&resp_body_text);\n        // parse and save sub_templates <template name=\"xxx\"></template>\n        rrc.web_data.html_sub_templates.clear();\n        loop {\n            let mut exist_template = false;\n\n            let pos1 = tm.find(\"<template \");\n            let del2 = \"</template>\";\n            let pos2 = tm.find(del2);\n            if let Some(pos_start) = pos1 {\n                if let Some(pos_end) = pos2 {\n                    exist_template = true;\n                    // drain - extract a substring and remove it from the original\n                    let sub1: String = tm.drain(pos_start..pos_end + del2.len()).collect();\n\n                    let del3 = \"name=\\\"\";\n                    let pos_name_start = unwrap!(sub1.find(del3));\n                    let sub2 = &sub1[pos_name_start + del3.len()..];\n                    //websysmod::debug_write(sub2);\n\n                    let pos_name_end = unwrap!(sub2.find('\"'));\n                    let name = &sub2[0..pos_name_end];\n                    //websysmod::debug_write(name);\n\n                    let del5 = '>';\n                    let pos_name_end_tag = unwrap!(sub1.find(del5));\n                    let pos6 = unwrap!(sub1.find(del2));\n                    let sub_template = &sub1[pos_name_end_tag + 1..pos6];\n                    //websysmod::debug_write(sub_template);\n\n                    rrc.web_data\n                        .html_sub_templates\n                        .push((name.to_string(), sub_template.to_string()));\n                }\n            }\n            if !exist_template {\n                break;\n            }\n        }\n        rrc.web_data.html_template = tm;\n}\n\n/// only the html between the <body> </body>\n/// it must be a SINGLE root node\nfn between_body_tag(resp_body_text: &str) -> String {\n    let pos1 = resp_body_text.find(\"<body>\").unwrap_or(0);\n    let pos2 = resp_body_text.find(\"</body>\").unwrap_or(0);\n    // return\n    if pos1 == 0 {\n        resp_body_text.to_string()\n    } else {\n        #[allow(clippy::integer_arithmetic)]\n        {\n            unwrap!(resp_body_text.get(pos1 + 6..pos2)).to_string()\n        }\n    }\n}\n"
    },
    {
      "file": "mem6/src/htmltemplateimplmod.rs",
      "line": 261,
      "description": "### call_fn_node\nThis fn will replace the next element after <!--n=fn_name--> with a Node.",
      "selection": {
        "start": {
          "line": 261,
          "character": 8
        },
        "end": {
          "line": 261,
          "character": 20
        }
      },
      "contents": "//! htmltemplateimplmod  \n\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\nuse rust_wasm_webrtc::webrtcmod::WebRtcTrait;\n\nuse unwrap::unwrap;\n//use wasm_bindgen::{JsCast};\nuse dodrio::{\n    Node, RenderContext, RootRender,\n    bumpalo::{self},\n    builder::{ElementBuilder, text},\n    VdomWeak,\n};\nuse web_sys::{Event};\n\nimpl htmltemplatemod::HtmlTemplating for RootRenderingComponent {\n    /// html_templating boolean id the next node is rendered or not\n    fn call_fn_boolean(&self, fn_name: &str) -> bool {\n        // websysmod::debug_write(&format!(\"call_fn_boolean: {}\", &fn_name));\n        match fn_name {\n            \"is_first_player\" => self.game_data.my_player_number == 1,\n            \"player_joined\" => self.game_data.players.len() > 1,\n            \"sounds_and_labels\" => self.game_data.sounds_and_labels,\n            \"rtc_is_data_channel_open\" => self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            \"is_not_rtc_data_channel_open\" => !self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_boolean: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                true\n            }\n        }\n    }\n\n    /// html_templating functions that return a String\n    #[allow(\n        clippy::needless_return,\n        clippy::integer_arithmetic,\n        clippy::indexing_slicing\n    )]\n    fn call_fn_string(&self, fn_name: &str) -> String {\n        // websysmod::debug_write(&format!(\"call_fn_string: {}\", &fn_name));\n        match fn_name {\n            \"my_nickname\" => self.game_data.my_nickname.to_owned(),\n            \"blink_or_not_nickname\" => storagemod::blink_or_not_nickname(self),\n            \"blink_or_not_group_id\" => blink_or_not_group_id(self),\n            \"my_ws_uid\" => format!(\"{}\", self.web_data.my_ws_uid),\n            \"receiver_ws_uid\" => format!(\"{}\", self.web_data.web_rtc_data.rtc_receiver_ws_uid),\n            \"players_count\" => format!(\"{} \", self.game_data.players.len() - 1),\n            \"game_name\" => self.game_data.game_name.to_string(),\n            \"group_id\" => self.game_data.group_id.to_string(),\n            \"url_to_join\" => format!(\"bestia.dev/mem6/#p03.{}\", self.web_data.my_ws_uid),\n            \"cargo_pkg_version\" => env!(\"CARGO_PKG_VERSION\").to_string(),\n            \"debug_text\" => websysmod::get_debug_text(),\n            \"game_status\" => self.game_data.game_status.as_ref().to_string(),\n            \"my_player_number\" => self.game_data.my_player_number.to_string(),\n            \"gameboard_btn\" => {\n                // different class depend on status\n                \"btn\".to_owned()\n            }\n            \"card_moniker_first\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_1st_card().card_number]\n                    .to_string();\n            }\n            \"card_moniker_second\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_2nd_card().card_number]\n                    .to_string();\n            }\n            \"my_points\" => {\n                return format!(\"{} \", self.game_data.my_player().points,);\n            }\n            \"player_turn_nickname\" => {\n                //websysmod::debug_write(\"player_turn_nickname\");\n                return self.game_data.player_turn_now().nickname.to_string();\n            }\n            \"sounds_and_labels\" => {\n                return if self.game_data.sounds_and_labels == true {\n                    \"sounds and labels ON\".to_string()\n                } else {\n                    \"sounds and labels OFF\".to_string()\n                };\n            }\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_string: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                x\n            }\n        }\n    }\n\n    /// return a closure for the listener.\n    #[allow(clippy::too_many_lines, clippy::type_complexity)]\n    fn call_fn_listener(\n        &self,\n        fn_name: String,\n    ) -> Box<dyn Fn(&mut dyn RootRender, VdomWeak, Event) + 'static> {\n        Box::new(move |root, vdom, event| {\n            let fn_name = fn_name.clone();\n            let fn_name = fn_name.as_str();\n            let rrc = root.unwrap_mut::<RootRenderingComponent>();\n            //websysmod::debug_write(&format!(\"call_fn_listener: {}\", &fn_name));\n            match fn_name {\n                \"nickname_onkeyup\" => {\n                    storagemod::nickname_onkeyup(rrc, event);\n                }\n                \"group_id_onkeyup\" => {\n                    storagemod::group_id_onkeyup(rrc, event);\n                }\n                \"open_youtube\" => {\n                    // randomly choose a link from rrc.videos\n                    let num = websysmod::get_random(0, rrc.game_data.videos.len());\n                    #[allow(clippy::indexing_slicing)]\n                    // cannot panic:the num is 0..video.len\n                    websysmod::open_new_tab(&format!(\n                        \"https://www.youtube.com/watch?v={}\",\n                        rrc.game_data.videos[num]\n                    ));\n                }\n                \"open_menu\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p21\");\n                }\n                \"sounds_and_labels\" => {\n                    // toggle sound and label on/off\n                    websysmod::debug_write(&format!(\"on click sounds and labels: {}\", \"\"));\n                    if rrc.game_data.sounds_and_labels == true {\n                        rrc.game_data.sounds_and_labels = false;\n                    } else {\n                        rrc.game_data.sounds_and_labels = true;\n                    }\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgSoundsAndLabels {\n                                sounds_and_labels: rrc.game_data.sounds_and_labels,\n                            },\n                        });\n                    vdom.schedule_render();\n                }\n                \"back_to_game\" => {\n                    let h = unwrap!(websysmod::window().history());\n                    let _x = h.back();\n                }\n                \"open_instructions\" => {\n                    websysmod::open_new_tab(\"#p08\");\n                }\n                \"debug_log\" => {\n                    websysmod::open_new_tab(\"#p31\");\n                }\n                \"webrtc\" => {\n                    open_new_local_page(\"#p41\");\n                }\n                \"web_rtc_receiver_ws_uid_onkeyup\" => {\n                    webrtcimplmod::web_rtc_receiver_ws_uid_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_start\" => {\n                    rrc.web_data.web_rtc_data\n                        .web_rtc_start(vdom, unwrap!(rrc.web_data.websocket_data.ws.clone()));\n                }\n                \"web_rtc_chat_text_onkeyup\" => {\n                    webrtcimplmod::web_rtc_chat_text_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_send_chat\" => {\n                    rrc.web_data.web_rtc_data.web_rtc_send_chat(vdom);\n                }\n                \"start_a_group_onclick\" => {\n                    // entry point for the game\n                    rrc.start_websocket(vdom);\n                    open_new_local_page(\"#p02\");\n                }\n                \"restart_game\" => {\n                    // send a msg to others to open #p04\n                    statusgameovermod::on_msg_play_again(rrc);\n                    open_new_local_page(\"#p02\");\n                }\n                \"join_a_group_onclick\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p03\");\n                }\n                \"choose_a_game_onclick\" => {\n                    open_new_local_page(\"#p05\");\n                }\n                \"start_game_onclick\" => {\n                    statusgamedatainitmod::on_click_start_game(rrc);\n                    // async fetch all imgs and put them in service worker cache\n                    fetchmod::fetch_all_img_for_cache_request(rrc);\n                    // websysmod::debug_write(&format!(\"start_game_onclick players: {:?}\",rrc.game_data.players));\n                    open_new_local_page(\"#p11\");\n                }\n                \"game_type_right_onclick\" => {\n                    game_type_right_onclick(rrc, vdom);\n                }\n                \"game_type_left_onclick\" => {\n                    game_type_left_onclick(rrc, vdom);\n                }\n                \"join_group_on_click\" => {\n                    open_new_local_page(\"#p04\");\n                }\n                \"drink_end\" => {\n                    // send a msg to end drinking to all players\n\n                    websysmod::debug_write(&format!(\"MsgDrinkEnd send{}\", \"\"));\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgDrinkEnd {},\n                        });\n                    // if all the cards are permanently up, this is the end of the game\n                    // websysmod::debug_write(\"if is_all_permanently(rrc)\");\n                    if status2ndcardmod::is_all_permanently(rrc) {\n                        websysmod::debug_write(\"yes\");\n                        statusgameovermod::on_msg_game_over(rrc);\n                        // send message\n                        rrc.web_data\n                            .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                                msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                                msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                                msg_data: gamedatamod::WsMessageGameData::MsgGameOver {},\n                            });\n                    } else {\n                        statustaketurnmod::on_click_take_turn(rrc, vdom.clone());\n                    }\n                    // end the drink page\n                    open_new_local_page(\"#p11\");\n                }\n                \"p06_load_image\" => {\n                    //websysmod::debug_write(\"p06_load_image\");\n                    statusdrinkmod::play_sound_for_drink(rrc);\n                }\n                \"play_again\" => {\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgPlayAgain {},\n                        });\n                    rrc.game_data.reset_for_play_again();\n                    open_new_local_page(\"#p05\");\n                }\n                \"on_click_img_status1st\" => {\n                    status1stcardmod::on_click_img_status1st(root, vdom.clone(), &event);\n                }\n                \"on_click_img_status2nd\" => {\n                    status2ndcardmod::on_click_img_status2nd(root, vdom.clone(), &event);\n                }\n                \"hide_big_img\" => {\n                    hide_big_img();\n                }\n                _ => {\n                    let x = format!(\"Error: Unrecognized call_fn_listener: \\\"{}\\\"\", fn_name);\n                    websysmod::debug_write(&x);\n                }\n            }\n        })\n    }\n\n    /// html_templating functions that return a Node\n    #[allow(clippy::needless_return)]\n    fn call_fn_node<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Node<'a> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_container\" => {\n                // what is the game_status now?\n                // websysmod::debug_write(&format!(\"game status: {}\", self.game_data.game_status));\n                let max_grid_size = divgridcontainermod::max_grid_size(self);\n                return divgridcontainermod::div_grid_container(self, cx, &max_grid_size);\n            }\n            \"div_player_action\" => {\n                let node = divplayeractionsmod::div_player_actions_from_game_status(self, cx);\n                return node;\n            }\n            \"svg_qrcode\" => {\n                return svg_qrcode_to_node(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return node;\n            }\n        }\n    }\n\n    /// html_templating functions that return a vector of Nodes\n    #[allow(clippy::needless_return)]\n    fn call_fn_vec_nodes<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Vec<Node<'a>> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_all_items\" => {\n                return divgridcontainermod::div_grid_all_items(self, cx);\n            }\n            \"web_rtc_div_messages\" => {\n                return webrtcimplmod::web_rtc_div_messages(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return vec![node];\n            }\n        }\n    }\n}\n\n/// qrcode svg\npub fn svg_qrcode_to_node<'a>(\n    rrc: &RootRenderingComponent,\n    cx: &mut RenderContext<'a>,\n) -> Node<'a> {\n    let link = format!(\"https://bestia.dev/mem6/#p03.{}\", rrc.web_data.my_ws_uid);\n    let qr = unwrap!(qrcode53bytes::Qr::new(&link));\n    let svg_template = qrcode53bytes::SvgDodrioRenderer::new(222, 222).render(&qr);\n    // i added use crate::htmltemplatemod::HtmlTemplating; to make the function render_template in scope.\n    unwrap!(rrc.render_template(cx, &svg_template, htmltemplatemod::HtmlOrSvg::Svg))\n}\n\n/// the arrow to the right\npub fn game_type_right_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.last()).name.to_string();\n    for x in gmd {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// left arrow button\npub fn game_type_left_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.first()).name.to_string();\n    for x in gmd.iter().rev() {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// fn open new local page with #\n/// does not push to history\npub fn open_new_local_page(hash: &str) {\n    // I want to put the first url in history.\n    // These are opened from outside my app and I cannot manage that differently.\n    // There are 2 of them:\n    // 1. if the players starts without hash\n    // 2. if the player scanned the qrcode and opened the p3 with group_id\n    // For links opened inside the app, I can call the open with or without history.\n    // For example for menu p21 I want to have a back button.\n    let (_old_location_href, old_href_hash) = websysmod::get_url_and_hash();\n    if old_href_hash.is_empty() || old_href_hash.starts_with(\"#p03.\") {\n        websysmod::open_new_local_page_push_to_history(hash)\n    } else {\n        let _x = websysmod::window().location().replace(hash);\n    }\n}\n\n/// if there is already a group_id don't blink\npub fn blink_or_not_group_id(rrc: &RootRenderingComponent) -> String {\n    if rrc.game_data.group_id == 0 {\n        \"blink\".to_owned()\n    } else {\n        \"\".to_owned()\n    }\n}\n\n/// hide big img\npub fn hide_big_img() {\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    let _x = img_html_element.style().set_property(\"display\", \"none\");\n}\n\n/// visible big img\npub fn visible_big_img(img_file_name: &str) {\n    websysmod::debug_write(img_file_name);\n    //change png in jpg for big img\n    let img_file_name = img_file_name.replace(\".png\", \".jpg\");\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    img_html_element.set_src(&img_file_name);\n    let _x = img_html_element.style().set_property(\"display\", \"initial\");\n}\n\n/// update html_template and extract and saves html_sub_templates\n#[allow(clippy::integer_arithmetic)]\n#[allow(clippy::indexing_slicing)]\npub fn update_html_template_and_sub_templates(rrc:&mut RootRenderingComponent, resp_body_text: &str,)  {\n        // only the html inside the <body> </body>\n        let mut tm = between_body_tag(&resp_body_text);\n        // parse and save sub_templates <template name=\"xxx\"></template>\n        rrc.web_data.html_sub_templates.clear();\n        loop {\n            let mut exist_template = false;\n\n            let pos1 = tm.find(\"<template \");\n            let del2 = \"</template>\";\n            let pos2 = tm.find(del2);\n            if let Some(pos_start) = pos1 {\n                if let Some(pos_end) = pos2 {\n                    exist_template = true;\n                    // drain - extract a substring and remove it from the original\n                    let sub1: String = tm.drain(pos_start..pos_end + del2.len()).collect();\n\n                    let del3 = \"name=\\\"\";\n                    let pos_name_start = unwrap!(sub1.find(del3));\n                    let sub2 = &sub1[pos_name_start + del3.len()..];\n                    //websysmod::debug_write(sub2);\n\n                    let pos_name_end = unwrap!(sub2.find('\"'));\n                    let name = &sub2[0..pos_name_end];\n                    //websysmod::debug_write(name);\n\n                    let del5 = '>';\n                    let pos_name_end_tag = unwrap!(sub1.find(del5));\n                    let pos6 = unwrap!(sub1.find(del2));\n                    let sub_template = &sub1[pos_name_end_tag + 1..pos6];\n                    //websysmod::debug_write(sub_template);\n\n                    rrc.web_data\n                        .html_sub_templates\n                        .push((name.to_string(), sub_template.to_string()));\n                }\n            }\n            if !exist_template {\n                break;\n            }\n        }\n        rrc.web_data.html_template = tm;\n}\n\n/// only the html between the <body> </body>\n/// it must be a SINGLE root node\nfn between_body_tag(resp_body_text: &str) -> String {\n    let pos1 = resp_body_text.find(\"<body>\").unwrap_or(0);\n    let pos2 = resp_body_text.find(\"</body>\").unwrap_or(0);\n    // return\n    if pos1 == 0 {\n        resp_body_text.to_string()\n    } else {\n        #[allow(clippy::integer_arithmetic)]\n        {\n            unwrap!(resp_body_text.get(pos1 + 6..pos2)).to_string()\n        }\n    }\n}\n"
    },
    {
      "file": "mem6/src/htmltemplateimplmod.rs",
      "line": 296,
      "description": "### call_fn_vec_nodes\nThis fn will replace the next element after <!--vn=fn_name--> with a Vector of Nodes.",
      "selection": {
        "start": {
          "line": 296,
          "character": 8
        },
        "end": {
          "line": 296,
          "character": 25
        }
      },
      "contents": "//! htmltemplateimplmod  \n\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\nuse rust_wasm_webrtc::webrtcmod::WebRtcTrait;\n\nuse unwrap::unwrap;\n//use wasm_bindgen::{JsCast};\nuse dodrio::{\n    Node, RenderContext, RootRender,\n    bumpalo::{self},\n    builder::{ElementBuilder, text},\n    VdomWeak,\n};\nuse web_sys::{Event};\n\nimpl htmltemplatemod::HtmlTemplating for RootRenderingComponent {\n    /// html_templating boolean id the next node is rendered or not\n    fn call_fn_boolean(&self, fn_name: &str) -> bool {\n        // websysmod::debug_write(&format!(\"call_fn_boolean: {}\", &fn_name));\n        match fn_name {\n            \"is_first_player\" => self.game_data.my_player_number == 1,\n            \"player_joined\" => self.game_data.players.len() > 1,\n            \"sounds_and_labels\" => self.game_data.sounds_and_labels,\n            \"rtc_is_data_channel_open\" => self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            \"is_not_rtc_data_channel_open\" => !self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_boolean: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                true\n            }\n        }\n    }\n\n    /// html_templating functions that return a String\n    #[allow(\n        clippy::needless_return,\n        clippy::integer_arithmetic,\n        clippy::indexing_slicing\n    )]\n    fn call_fn_string(&self, fn_name: &str) -> String {\n        // websysmod::debug_write(&format!(\"call_fn_string: {}\", &fn_name));\n        match fn_name {\n            \"my_nickname\" => self.game_data.my_nickname.to_owned(),\n            \"blink_or_not_nickname\" => storagemod::blink_or_not_nickname(self),\n            \"blink_or_not_group_id\" => blink_or_not_group_id(self),\n            \"my_ws_uid\" => format!(\"{}\", self.web_data.my_ws_uid),\n            \"receiver_ws_uid\" => format!(\"{}\", self.web_data.web_rtc_data.rtc_receiver_ws_uid),\n            \"players_count\" => format!(\"{} \", self.game_data.players.len() - 1),\n            \"game_name\" => self.game_data.game_name.to_string(),\n            \"group_id\" => self.game_data.group_id.to_string(),\n            \"url_to_join\" => format!(\"bestia.dev/mem6/#p03.{}\", self.web_data.my_ws_uid),\n            \"cargo_pkg_version\" => env!(\"CARGO_PKG_VERSION\").to_string(),\n            \"debug_text\" => websysmod::get_debug_text(),\n            \"game_status\" => self.game_data.game_status.as_ref().to_string(),\n            \"my_player_number\" => self.game_data.my_player_number.to_string(),\n            \"gameboard_btn\" => {\n                // different class depend on status\n                \"btn\".to_owned()\n            }\n            \"card_moniker_first\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_1st_card().card_number]\n                    .to_string();\n            }\n            \"card_moniker_second\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_2nd_card().card_number]\n                    .to_string();\n            }\n            \"my_points\" => {\n                return format!(\"{} \", self.game_data.my_player().points,);\n            }\n            \"player_turn_nickname\" => {\n                //websysmod::debug_write(\"player_turn_nickname\");\n                return self.game_data.player_turn_now().nickname.to_string();\n            }\n            \"sounds_and_labels\" => {\n                return if self.game_data.sounds_and_labels == true {\n                    \"sounds and labels ON\".to_string()\n                } else {\n                    \"sounds and labels OFF\".to_string()\n                };\n            }\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_string: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                x\n            }\n        }\n    }\n\n    /// return a closure for the listener.\n    #[allow(clippy::too_many_lines, clippy::type_complexity)]\n    fn call_fn_listener(\n        &self,\n        fn_name: String,\n    ) -> Box<dyn Fn(&mut dyn RootRender, VdomWeak, Event) + 'static> {\n        Box::new(move |root, vdom, event| {\n            let fn_name = fn_name.clone();\n            let fn_name = fn_name.as_str();\n            let rrc = root.unwrap_mut::<RootRenderingComponent>();\n            //websysmod::debug_write(&format!(\"call_fn_listener: {}\", &fn_name));\n            match fn_name {\n                \"nickname_onkeyup\" => {\n                    storagemod::nickname_onkeyup(rrc, event);\n                }\n                \"group_id_onkeyup\" => {\n                    storagemod::group_id_onkeyup(rrc, event);\n                }\n                \"open_youtube\" => {\n                    // randomly choose a link from rrc.videos\n                    let num = websysmod::get_random(0, rrc.game_data.videos.len());\n                    #[allow(clippy::indexing_slicing)]\n                    // cannot panic:the num is 0..video.len\n                    websysmod::open_new_tab(&format!(\n                        \"https://www.youtube.com/watch?v={}\",\n                        rrc.game_data.videos[num]\n                    ));\n                }\n                \"open_menu\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p21\");\n                }\n                \"sounds_and_labels\" => {\n                    // toggle sound and label on/off\n                    websysmod::debug_write(&format!(\"on click sounds and labels: {}\", \"\"));\n                    if rrc.game_data.sounds_and_labels == true {\n                        rrc.game_data.sounds_and_labels = false;\n                    } else {\n                        rrc.game_data.sounds_and_labels = true;\n                    }\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgSoundsAndLabels {\n                                sounds_and_labels: rrc.game_data.sounds_and_labels,\n                            },\n                        });\n                    vdom.schedule_render();\n                }\n                \"back_to_game\" => {\n                    let h = unwrap!(websysmod::window().history());\n                    let _x = h.back();\n                }\n                \"open_instructions\" => {\n                    websysmod::open_new_tab(\"#p08\");\n                }\n                \"debug_log\" => {\n                    websysmod::open_new_tab(\"#p31\");\n                }\n                \"webrtc\" => {\n                    open_new_local_page(\"#p41\");\n                }\n                \"web_rtc_receiver_ws_uid_onkeyup\" => {\n                    webrtcimplmod::web_rtc_receiver_ws_uid_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_start\" => {\n                    rrc.web_data.web_rtc_data\n                        .web_rtc_start(vdom, unwrap!(rrc.web_data.websocket_data.ws.clone()));\n                }\n                \"web_rtc_chat_text_onkeyup\" => {\n                    webrtcimplmod::web_rtc_chat_text_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_send_chat\" => {\n                    rrc.web_data.web_rtc_data.web_rtc_send_chat(vdom);\n                }\n                \"start_a_group_onclick\" => {\n                    // entry point for the game\n                    rrc.start_websocket(vdom);\n                    open_new_local_page(\"#p02\");\n                }\n                \"restart_game\" => {\n                    // send a msg to others to open #p04\n                    statusgameovermod::on_msg_play_again(rrc);\n                    open_new_local_page(\"#p02\");\n                }\n                \"join_a_group_onclick\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p03\");\n                }\n                \"choose_a_game_onclick\" => {\n                    open_new_local_page(\"#p05\");\n                }\n                \"start_game_onclick\" => {\n                    statusgamedatainitmod::on_click_start_game(rrc);\n                    // async fetch all imgs and put them in service worker cache\n                    fetchmod::fetch_all_img_for_cache_request(rrc);\n                    // websysmod::debug_write(&format!(\"start_game_onclick players: {:?}\",rrc.game_data.players));\n                    open_new_local_page(\"#p11\");\n                }\n                \"game_type_right_onclick\" => {\n                    game_type_right_onclick(rrc, vdom);\n                }\n                \"game_type_left_onclick\" => {\n                    game_type_left_onclick(rrc, vdom);\n                }\n                \"join_group_on_click\" => {\n                    open_new_local_page(\"#p04\");\n                }\n                \"drink_end\" => {\n                    // send a msg to end drinking to all players\n\n                    websysmod::debug_write(&format!(\"MsgDrinkEnd send{}\", \"\"));\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgDrinkEnd {},\n                        });\n                    // if all the cards are permanently up, this is the end of the game\n                    // websysmod::debug_write(\"if is_all_permanently(rrc)\");\n                    if status2ndcardmod::is_all_permanently(rrc) {\n                        websysmod::debug_write(\"yes\");\n                        statusgameovermod::on_msg_game_over(rrc);\n                        // send message\n                        rrc.web_data\n                            .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                                msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                                msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                                msg_data: gamedatamod::WsMessageGameData::MsgGameOver {},\n                            });\n                    } else {\n                        statustaketurnmod::on_click_take_turn(rrc, vdom.clone());\n                    }\n                    // end the drink page\n                    open_new_local_page(\"#p11\");\n                }\n                \"p06_load_image\" => {\n                    //websysmod::debug_write(\"p06_load_image\");\n                    statusdrinkmod::play_sound_for_drink(rrc);\n                }\n                \"play_again\" => {\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgPlayAgain {},\n                        });\n                    rrc.game_data.reset_for_play_again();\n                    open_new_local_page(\"#p05\");\n                }\n                \"on_click_img_status1st\" => {\n                    status1stcardmod::on_click_img_status1st(root, vdom.clone(), &event);\n                }\n                \"on_click_img_status2nd\" => {\n                    status2ndcardmod::on_click_img_status2nd(root, vdom.clone(), &event);\n                }\n                \"hide_big_img\" => {\n                    hide_big_img();\n                }\n                _ => {\n                    let x = format!(\"Error: Unrecognized call_fn_listener: \\\"{}\\\"\", fn_name);\n                    websysmod::debug_write(&x);\n                }\n            }\n        })\n    }\n\n    /// html_templating functions that return a Node\n    #[allow(clippy::needless_return)]\n    fn call_fn_node<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Node<'a> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_container\" => {\n                // what is the game_status now?\n                // websysmod::debug_write(&format!(\"game status: {}\", self.game_data.game_status));\n                let max_grid_size = divgridcontainermod::max_grid_size(self);\n                return divgridcontainermod::div_grid_container(self, cx, &max_grid_size);\n            }\n            \"div_player_action\" => {\n                let node = divplayeractionsmod::div_player_actions_from_game_status(self, cx);\n                return node;\n            }\n            \"svg_qrcode\" => {\n                return svg_qrcode_to_node(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return node;\n            }\n        }\n    }\n\n    /// html_templating functions that return a vector of Nodes\n    #[allow(clippy::needless_return)]\n    fn call_fn_vec_nodes<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Vec<Node<'a>> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_all_items\" => {\n                return divgridcontainermod::div_grid_all_items(self, cx);\n            }\n            \"web_rtc_div_messages\" => {\n                return webrtcimplmod::web_rtc_div_messages(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return vec![node];\n            }\n        }\n    }\n}\n\n/// qrcode svg\npub fn svg_qrcode_to_node<'a>(\n    rrc: &RootRenderingComponent,\n    cx: &mut RenderContext<'a>,\n) -> Node<'a> {\n    let link = format!(\"https://bestia.dev/mem6/#p03.{}\", rrc.web_data.my_ws_uid);\n    let qr = unwrap!(qrcode53bytes::Qr::new(&link));\n    let svg_template = qrcode53bytes::SvgDodrioRenderer::new(222, 222).render(&qr);\n    // i added use crate::htmltemplatemod::HtmlTemplating; to make the function render_template in scope.\n    unwrap!(rrc.render_template(cx, &svg_template, htmltemplatemod::HtmlOrSvg::Svg))\n}\n\n/// the arrow to the right\npub fn game_type_right_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.last()).name.to_string();\n    for x in gmd {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// left arrow button\npub fn game_type_left_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.first()).name.to_string();\n    for x in gmd.iter().rev() {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// fn open new local page with #\n/// does not push to history\npub fn open_new_local_page(hash: &str) {\n    // I want to put the first url in history.\n    // These are opened from outside my app and I cannot manage that differently.\n    // There are 2 of them:\n    // 1. if the players starts without hash\n    // 2. if the player scanned the qrcode and opened the p3 with group_id\n    // For links opened inside the app, I can call the open with or without history.\n    // For example for menu p21 I want to have a back button.\n    let (_old_location_href, old_href_hash) = websysmod::get_url_and_hash();\n    if old_href_hash.is_empty() || old_href_hash.starts_with(\"#p03.\") {\n        websysmod::open_new_local_page_push_to_history(hash)\n    } else {\n        let _x = websysmod::window().location().replace(hash);\n    }\n}\n\n/// if there is already a group_id don't blink\npub fn blink_or_not_group_id(rrc: &RootRenderingComponent) -> String {\n    if rrc.game_data.group_id == 0 {\n        \"blink\".to_owned()\n    } else {\n        \"\".to_owned()\n    }\n}\n\n/// hide big img\npub fn hide_big_img() {\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    let _x = img_html_element.style().set_property(\"display\", \"none\");\n}\n\n/// visible big img\npub fn visible_big_img(img_file_name: &str) {\n    websysmod::debug_write(img_file_name);\n    //change png in jpg for big img\n    let img_file_name = img_file_name.replace(\".png\", \".jpg\");\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    img_html_element.set_src(&img_file_name);\n    let _x = img_html_element.style().set_property(\"display\", \"initial\");\n}\n\n/// update html_template and extract and saves html_sub_templates\n#[allow(clippy::integer_arithmetic)]\n#[allow(clippy::indexing_slicing)]\npub fn update_html_template_and_sub_templates(rrc:&mut RootRenderingComponent, resp_body_text: &str,)  {\n        // only the html inside the <body> </body>\n        let mut tm = between_body_tag(&resp_body_text);\n        // parse and save sub_templates <template name=\"xxx\"></template>\n        rrc.web_data.html_sub_templates.clear();\n        loop {\n            let mut exist_template = false;\n\n            let pos1 = tm.find(\"<template \");\n            let del2 = \"</template>\";\n            let pos2 = tm.find(del2);\n            if let Some(pos_start) = pos1 {\n                if let Some(pos_end) = pos2 {\n                    exist_template = true;\n                    // drain - extract a substring and remove it from the original\n                    let sub1: String = tm.drain(pos_start..pos_end + del2.len()).collect();\n\n                    let del3 = \"name=\\\"\";\n                    let pos_name_start = unwrap!(sub1.find(del3));\n                    let sub2 = &sub1[pos_name_start + del3.len()..];\n                    //websysmod::debug_write(sub2);\n\n                    let pos_name_end = unwrap!(sub2.find('\"'));\n                    let name = &sub2[0..pos_name_end];\n                    //websysmod::debug_write(name);\n\n                    let del5 = '>';\n                    let pos_name_end_tag = unwrap!(sub1.find(del5));\n                    let pos6 = unwrap!(sub1.find(del2));\n                    let sub_template = &sub1[pos_name_end_tag + 1..pos6];\n                    //websysmod::debug_write(sub_template);\n\n                    rrc.web_data\n                        .html_sub_templates\n                        .push((name.to_string(), sub_template.to_string()));\n                }\n            }\n            if !exist_template {\n                break;\n            }\n        }\n        rrc.web_data.html_template = tm;\n}\n\n/// only the html between the <body> </body>\n/// it must be a SINGLE root node\nfn between_body_tag(resp_body_text: &str) -> String {\n    let pos1 = resp_body_text.find(\"<body>\").unwrap_or(0);\n    let pos2 = resp_body_text.find(\"</body>\").unwrap_or(0);\n    // return\n    if pos1 == 0 {\n        resp_body_text.to_string()\n    } else {\n        #[allow(clippy::integer_arithmetic)]\n        {\n            unwrap!(resp_body_text.get(pos1 + 6..pos2)).to_string()\n        }\n    }\n}\n"
    },
    {
      "file": "mem6/src/htmltemplateimplmod.rs",
      "line": 19,
      "description": "### call_fn_boolean\nThis fn will remove the next element after <!--b=fn_name--> if the result is `false`.",
      "selection": {
        "start": {
          "line": 19,
          "character": 8
        },
        "end": {
          "line": 19,
          "character": 23
        }
      },
      "contents": "//! htmltemplateimplmod  \n\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\nuse rust_wasm_webrtc::webrtcmod::WebRtcTrait;\n\nuse unwrap::unwrap;\n//use wasm_bindgen::{JsCast};\nuse dodrio::{\n    Node, RenderContext, RootRender,\n    bumpalo::{self},\n    builder::{ElementBuilder, text},\n    VdomWeak,\n};\nuse web_sys::{Event};\n\nimpl htmltemplatemod::HtmlTemplating for RootRenderingComponent {\n    /// html_templating boolean id the next node is rendered or not\n    fn call_fn_boolean(&self, fn_name: &str) -> bool {\n        // websysmod::debug_write(&format!(\"call_fn_boolean: {}\", &fn_name));\n        match fn_name {\n            \"is_first_player\" => self.game_data.my_player_number == 1,\n            \"player_joined\" => self.game_data.players.len() > 1,\n            \"sounds_and_labels\" => self.game_data.sounds_and_labels,\n            \"rtc_is_data_channel_open\" => self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            \"is_not_rtc_data_channel_open\" => !self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_boolean: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                true\n            }\n        }\n    }\n\n    /// html_templating functions that return a String\n    #[allow(\n        clippy::needless_return,\n        clippy::integer_arithmetic,\n        clippy::indexing_slicing\n    )]\n    fn call_fn_string(&self, fn_name: &str) -> String {\n        // websysmod::debug_write(&format!(\"call_fn_string: {}\", &fn_name));\n        match fn_name {\n            \"my_nickname\" => self.game_data.my_nickname.to_owned(),\n            \"blink_or_not_nickname\" => storagemod::blink_or_not_nickname(self),\n            \"blink_or_not_group_id\" => blink_or_not_group_id(self),\n            \"my_ws_uid\" => format!(\"{}\", self.web_data.my_ws_uid),\n            \"receiver_ws_uid\" => format!(\"{}\", self.web_data.web_rtc_data.rtc_receiver_ws_uid),\n            \"players_count\" => format!(\"{} \", self.game_data.players.len() - 1),\n            \"game_name\" => self.game_data.game_name.to_string(),\n            \"group_id\" => self.game_data.group_id.to_string(),\n            \"url_to_join\" => format!(\"bestia.dev/mem6/#p03.{}\", self.web_data.my_ws_uid),\n            \"cargo_pkg_version\" => env!(\"CARGO_PKG_VERSION\").to_string(),\n            \"debug_text\" => websysmod::get_debug_text(),\n            \"game_status\" => self.game_data.game_status.as_ref().to_string(),\n            \"my_player_number\" => self.game_data.my_player_number.to_string(),\n            \"gameboard_btn\" => {\n                // different class depend on status\n                \"btn\".to_owned()\n            }\n            \"card_moniker_first\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_1st_card().card_number]\n                    .to_string();\n            }\n            \"card_moniker_second\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_2nd_card().card_number]\n                    .to_string();\n            }\n            \"my_points\" => {\n                return format!(\"{} \", self.game_data.my_player().points,);\n            }\n            \"player_turn_nickname\" => {\n                //websysmod::debug_write(\"player_turn_nickname\");\n                return self.game_data.player_turn_now().nickname.to_string();\n            }\n            \"sounds_and_labels\" => {\n                return if self.game_data.sounds_and_labels == true {\n                    \"sounds and labels ON\".to_string()\n                } else {\n                    \"sounds and labels OFF\".to_string()\n                };\n            }\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_string: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                x\n            }\n        }\n    }\n\n    /// return a closure for the listener.\n    #[allow(clippy::too_many_lines, clippy::type_complexity)]\n    fn call_fn_listener(\n        &self,\n        fn_name: String,\n    ) -> Box<dyn Fn(&mut dyn RootRender, VdomWeak, Event) + 'static> {\n        Box::new(move |root, vdom, event| {\n            let fn_name = fn_name.clone();\n            let fn_name = fn_name.as_str();\n            let rrc = root.unwrap_mut::<RootRenderingComponent>();\n            //websysmod::debug_write(&format!(\"call_fn_listener: {}\", &fn_name));\n            match fn_name {\n                \"nickname_onkeyup\" => {\n                    storagemod::nickname_onkeyup(rrc, event);\n                }\n                \"group_id_onkeyup\" => {\n                    storagemod::group_id_onkeyup(rrc, event);\n                }\n                \"open_youtube\" => {\n                    // randomly choose a link from rrc.videos\n                    let num = websysmod::get_random(0, rrc.game_data.videos.len());\n                    #[allow(clippy::indexing_slicing)]\n                    // cannot panic:the num is 0..video.len\n                    websysmod::open_new_tab(&format!(\n                        \"https://www.youtube.com/watch?v={}\",\n                        rrc.game_data.videos[num]\n                    ));\n                }\n                \"open_menu\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p21\");\n                }\n                \"sounds_and_labels\" => {\n                    // toggle sound and label on/off\n                    websysmod::debug_write(&format!(\"on click sounds and labels: {}\", \"\"));\n                    if rrc.game_data.sounds_and_labels == true {\n                        rrc.game_data.sounds_and_labels = false;\n                    } else {\n                        rrc.game_data.sounds_and_labels = true;\n                    }\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgSoundsAndLabels {\n                                sounds_and_labels: rrc.game_data.sounds_and_labels,\n                            },\n                        });\n                    vdom.schedule_render();\n                }\n                \"back_to_game\" => {\n                    let h = unwrap!(websysmod::window().history());\n                    let _x = h.back();\n                }\n                \"open_instructions\" => {\n                    websysmod::open_new_tab(\"#p08\");\n                }\n                \"debug_log\" => {\n                    websysmod::open_new_tab(\"#p31\");\n                }\n                \"webrtc\" => {\n                    open_new_local_page(\"#p41\");\n                }\n                \"web_rtc_receiver_ws_uid_onkeyup\" => {\n                    webrtcimplmod::web_rtc_receiver_ws_uid_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_start\" => {\n                    rrc.web_data.web_rtc_data\n                        .web_rtc_start(vdom, unwrap!(rrc.web_data.websocket_data.ws.clone()));\n                }\n                \"web_rtc_chat_text_onkeyup\" => {\n                    webrtcimplmod::web_rtc_chat_text_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_send_chat\" => {\n                    rrc.web_data.web_rtc_data.web_rtc_send_chat(vdom);\n                }\n                \"start_a_group_onclick\" => {\n                    // entry point for the game\n                    rrc.start_websocket(vdom);\n                    open_new_local_page(\"#p02\");\n                }\n                \"restart_game\" => {\n                    // send a msg to others to open #p04\n                    statusgameovermod::on_msg_play_again(rrc);\n                    open_new_local_page(\"#p02\");\n                }\n                \"join_a_group_onclick\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p03\");\n                }\n                \"choose_a_game_onclick\" => {\n                    open_new_local_page(\"#p05\");\n                }\n                \"start_game_onclick\" => {\n                    statusgamedatainitmod::on_click_start_game(rrc);\n                    // async fetch all imgs and put them in service worker cache\n                    fetchmod::fetch_all_img_for_cache_request(rrc);\n                    // websysmod::debug_write(&format!(\"start_game_onclick players: {:?}\",rrc.game_data.players));\n                    open_new_local_page(\"#p11\");\n                }\n                \"game_type_right_onclick\" => {\n                    game_type_right_onclick(rrc, vdom);\n                }\n                \"game_type_left_onclick\" => {\n                    game_type_left_onclick(rrc, vdom);\n                }\n                \"join_group_on_click\" => {\n                    open_new_local_page(\"#p04\");\n                }\n                \"drink_end\" => {\n                    // send a msg to end drinking to all players\n\n                    websysmod::debug_write(&format!(\"MsgDrinkEnd send{}\", \"\"));\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgDrinkEnd {},\n                        });\n                    // if all the cards are permanently up, this is the end of the game\n                    // websysmod::debug_write(\"if is_all_permanently(rrc)\");\n                    if status2ndcardmod::is_all_permanently(rrc) {\n                        websysmod::debug_write(\"yes\");\n                        statusgameovermod::on_msg_game_over(rrc);\n                        // send message\n                        rrc.web_data\n                            .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                                msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                                msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                                msg_data: gamedatamod::WsMessageGameData::MsgGameOver {},\n                            });\n                    } else {\n                        statustaketurnmod::on_click_take_turn(rrc, vdom.clone());\n                    }\n                    // end the drink page\n                    open_new_local_page(\"#p11\");\n                }\n                \"p06_load_image\" => {\n                    //websysmod::debug_write(\"p06_load_image\");\n                    statusdrinkmod::play_sound_for_drink(rrc);\n                }\n                \"play_again\" => {\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgPlayAgain {},\n                        });\n                    rrc.game_data.reset_for_play_again();\n                    open_new_local_page(\"#p05\");\n                }\n                \"on_click_img_status1st\" => {\n                    status1stcardmod::on_click_img_status1st(root, vdom.clone(), &event);\n                }\n                \"on_click_img_status2nd\" => {\n                    status2ndcardmod::on_click_img_status2nd(root, vdom.clone(), &event);\n                }\n                \"hide_big_img\" => {\n                    hide_big_img();\n                }\n                _ => {\n                    let x = format!(\"Error: Unrecognized call_fn_listener: \\\"{}\\\"\", fn_name);\n                    websysmod::debug_write(&x);\n                }\n            }\n        })\n    }\n\n    /// html_templating functions that return a Node\n    #[allow(clippy::needless_return)]\n    fn call_fn_node<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Node<'a> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_container\" => {\n                // what is the game_status now?\n                // websysmod::debug_write(&format!(\"game status: {}\", self.game_data.game_status));\n                let max_grid_size = divgridcontainermod::max_grid_size(self);\n                return divgridcontainermod::div_grid_container(self, cx, &max_grid_size);\n            }\n            \"div_player_action\" => {\n                let node = divplayeractionsmod::div_player_actions_from_game_status(self, cx);\n                return node;\n            }\n            \"svg_qrcode\" => {\n                return svg_qrcode_to_node(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return node;\n            }\n        }\n    }\n\n    /// html_templating functions that return a vector of Nodes\n    #[allow(clippy::needless_return)]\n    fn call_fn_vec_nodes<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Vec<Node<'a>> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_all_items\" => {\n                return divgridcontainermod::div_grid_all_items(self, cx);\n            }\n            \"web_rtc_div_messages\" => {\n                return webrtcimplmod::web_rtc_div_messages(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return vec![node];\n            }\n        }\n    }\n}\n\n/// qrcode svg\npub fn svg_qrcode_to_node<'a>(\n    rrc: &RootRenderingComponent,\n    cx: &mut RenderContext<'a>,\n) -> Node<'a> {\n    let link = format!(\"https://bestia.dev/mem6/#p03.{}\", rrc.web_data.my_ws_uid);\n    let qr = unwrap!(qrcode53bytes::Qr::new(&link));\n    let svg_template = qrcode53bytes::SvgDodrioRenderer::new(222, 222).render(&qr);\n    // i added use crate::htmltemplatemod::HtmlTemplating; to make the function render_template in scope.\n    unwrap!(rrc.render_template(cx, &svg_template, htmltemplatemod::HtmlOrSvg::Svg))\n}\n\n/// the arrow to the right\npub fn game_type_right_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.last()).name.to_string();\n    for x in gmd {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// left arrow button\npub fn game_type_left_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.first()).name.to_string();\n    for x in gmd.iter().rev() {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// fn open new local page with #\n/// does not push to history\npub fn open_new_local_page(hash: &str) {\n    // I want to put the first url in history.\n    // These are opened from outside my app and I cannot manage that differently.\n    // There are 2 of them:\n    // 1. if the players starts without hash\n    // 2. if the player scanned the qrcode and opened the p3 with group_id\n    // For links opened inside the app, I can call the open with or without history.\n    // For example for menu p21 I want to have a back button.\n    let (_old_location_href, old_href_hash) = websysmod::get_url_and_hash();\n    if old_href_hash.is_empty() || old_href_hash.starts_with(\"#p03.\") {\n        websysmod::open_new_local_page_push_to_history(hash)\n    } else {\n        let _x = websysmod::window().location().replace(hash);\n    }\n}\n\n/// if there is already a group_id don't blink\npub fn blink_or_not_group_id(rrc: &RootRenderingComponent) -> String {\n    if rrc.game_data.group_id == 0 {\n        \"blink\".to_owned()\n    } else {\n        \"\".to_owned()\n    }\n}\n\n/// hide big img\npub fn hide_big_img() {\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    let _x = img_html_element.style().set_property(\"display\", \"none\");\n}\n\n/// visible big img\npub fn visible_big_img(img_file_name: &str) {\n    websysmod::debug_write(img_file_name);\n    //change png in jpg for big img\n    let img_file_name = img_file_name.replace(\".png\", \".jpg\");\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    img_html_element.set_src(&img_file_name);\n    let _x = img_html_element.style().set_property(\"display\", \"initial\");\n}\n\n/// update html_template and extract and saves html_sub_templates\n#[allow(clippy::integer_arithmetic)]\n#[allow(clippy::indexing_slicing)]\npub fn update_html_template_and_sub_templates(rrc:&mut RootRenderingComponent, resp_body_text: &str,)  {\n        // only the html inside the <body> </body>\n        let mut tm = between_body_tag(&resp_body_text);\n        // parse and save sub_templates <template name=\"xxx\"></template>\n        rrc.web_data.html_sub_templates.clear();\n        loop {\n            let mut exist_template = false;\n\n            let pos1 = tm.find(\"<template \");\n            let del2 = \"</template>\";\n            let pos2 = tm.find(del2);\n            if let Some(pos_start) = pos1 {\n                if let Some(pos_end) = pos2 {\n                    exist_template = true;\n                    // drain - extract a substring and remove it from the original\n                    let sub1: String = tm.drain(pos_start..pos_end + del2.len()).collect();\n\n                    let del3 = \"name=\\\"\";\n                    let pos_name_start = unwrap!(sub1.find(del3));\n                    let sub2 = &sub1[pos_name_start + del3.len()..];\n                    //websysmod::debug_write(sub2);\n\n                    let pos_name_end = unwrap!(sub2.find('\"'));\n                    let name = &sub2[0..pos_name_end];\n                    //websysmod::debug_write(name);\n\n                    let del5 = '>';\n                    let pos_name_end_tag = unwrap!(sub1.find(del5));\n                    let pos6 = unwrap!(sub1.find(del2));\n                    let sub_template = &sub1[pos_name_end_tag + 1..pos6];\n                    //websysmod::debug_write(sub_template);\n\n                    rrc.web_data\n                        .html_sub_templates\n                        .push((name.to_string(), sub_template.to_string()));\n                }\n            }\n            if !exist_template {\n                break;\n            }\n        }\n        rrc.web_data.html_template = tm;\n}\n\n/// only the html between the <body> </body>\n/// it must be a SINGLE root node\nfn between_body_tag(resp_body_text: &str) -> String {\n    let pos1 = resp_body_text.find(\"<body>\").unwrap_or(0);\n    let pos2 = resp_body_text.find(\"</body>\").unwrap_or(0);\n    // return\n    if pos1 == 0 {\n        resp_body_text.to_string()\n    } else {\n        #[allow(clippy::integer_arithmetic)]\n        {\n            unwrap!(resp_body_text.get(pos1 + 6..pos2)).to_string()\n        }\n    }\n}\n"
    },
    {
      "file": "mem6/src/htmltemplateimplmod.rs",
      "line": 98,
      "description": "### call_fn_listener\nThis fn will add a listener to the element after `data-on-click=\"fn_name\"`.",
      "selection": {
        "start": {
          "line": 95,
          "character": 8
        },
        "end": {
          "line": 95,
          "character": 24
        }
      },
      "contents": "//! htmltemplateimplmod  \n\nuse crate::*;\nuse crate::htmltemplatemod::HtmlTemplating;\nuse rust_wasm_webrtc::webrtcmod::WebRtcTrait;\n\nuse unwrap::unwrap;\n//use wasm_bindgen::{JsCast};\nuse dodrio::{\n    Node, RenderContext, RootRender,\n    bumpalo::{self},\n    builder::{ElementBuilder, text},\n    VdomWeak,\n};\nuse web_sys::{Event};\n\nimpl htmltemplatemod::HtmlTemplating for RootRenderingComponent {\n    /// html_templating boolean id the next node is rendered or not\n    fn call_fn_boolean(&self, fn_name: &str) -> bool {\n        // websysmod::debug_write(&format!(\"call_fn_boolean: {}\", &fn_name));\n        match fn_name {\n            \"is_first_player\" => self.game_data.my_player_number == 1,\n            \"player_joined\" => self.game_data.players.len() > 1,\n            \"sounds_and_labels\" => self.game_data.sounds_and_labels,\n            \"rtc_is_data_channel_open\" => self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            \"is_not_rtc_data_channel_open\" => !self.web_data.web_rtc_data.rtc_is_data_channel_open,\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_boolean: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                true\n            }\n        }\n    }\n\n    /// html_templating functions that return a String\n    #[allow(\n        clippy::needless_return,\n        clippy::integer_arithmetic,\n        clippy::indexing_slicing\n    )]\n    fn call_fn_string(&self, fn_name: &str) -> String {\n        // websysmod::debug_write(&format!(\"call_fn_string: {}\", &fn_name));\n        match fn_name {\n            \"my_nickname\" => self.game_data.my_nickname.to_owned(),\n            \"blink_or_not_nickname\" => storagemod::blink_or_not_nickname(self),\n            \"blink_or_not_group_id\" => blink_or_not_group_id(self),\n            \"my_ws_uid\" => format!(\"{}\", self.web_data.my_ws_uid),\n            \"receiver_ws_uid\" => format!(\"{}\", self.web_data.web_rtc_data.rtc_receiver_ws_uid),\n            \"players_count\" => format!(\"{} \", self.game_data.players.len() - 1),\n            \"game_name\" => self.game_data.game_name.to_string(),\n            \"group_id\" => self.game_data.group_id.to_string(),\n            \"url_to_join\" => format!(\"bestia.dev/mem6/#p03.{}\", self.web_data.my_ws_uid),\n            \"cargo_pkg_version\" => env!(\"CARGO_PKG_VERSION\").to_string(),\n            \"debug_text\" => websysmod::get_debug_text(),\n            \"game_status\" => self.game_data.game_status.as_ref().to_string(),\n            \"my_player_number\" => self.game_data.my_player_number.to_string(),\n            \"gameboard_btn\" => {\n                // different class depend on status\n                \"btn\".to_owned()\n            }\n            \"card_moniker_first\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_1st_card().card_number]\n                    .to_string();\n            }\n            \"card_moniker_second\" => {\n                return unwrap!(self.game_data.game_config.as_ref()).card_moniker\n                    [self.game_data.get_2nd_card().card_number]\n                    .to_string();\n            }\n            \"my_points\" => {\n                return format!(\"{} \", self.game_data.my_player().points,);\n            }\n            \"player_turn_nickname\" => {\n                //websysmod::debug_write(\"player_turn_nickname\");\n                return self.game_data.player_turn_now().nickname.to_string();\n            }\n            \"sounds_and_labels\" => {\n                return if self.game_data.sounds_and_labels == true {\n                    \"sounds and labels ON\".to_string()\n                } else {\n                    \"sounds and labels OFF\".to_string()\n                };\n            }\n            _ => {\n                let x = format!(\"Error: Unrecognized call_fn_string: \\\"{}\\\"\", fn_name);\n                websysmod::debug_write(&x);\n                x\n            }\n        }\n    }\n\n    /// return a closure for the listener.\n    #[allow(clippy::too_many_lines, clippy::type_complexity)]\n    fn call_fn_listener(\n        &self,\n        fn_name: String,\n    ) -> Box<dyn Fn(&mut dyn RootRender, VdomWeak, Event) + 'static> {\n        Box::new(move |root, vdom, event| {\n            let fn_name = fn_name.clone();\n            let fn_name = fn_name.as_str();\n            let rrc = root.unwrap_mut::<RootRenderingComponent>();\n            //websysmod::debug_write(&format!(\"call_fn_listener: {}\", &fn_name));\n            match fn_name {\n                \"nickname_onkeyup\" => {\n                    storagemod::nickname_onkeyup(rrc, event);\n                }\n                \"group_id_onkeyup\" => {\n                    storagemod::group_id_onkeyup(rrc, event);\n                }\n                \"open_youtube\" => {\n                    // randomly choose a link from rrc.videos\n                    let num = websysmod::get_random(0, rrc.game_data.videos.len());\n                    #[allow(clippy::indexing_slicing)]\n                    // cannot panic:the num is 0..video.len\n                    websysmod::open_new_tab(&format!(\n                        \"https://www.youtube.com/watch?v={}\",\n                        rrc.game_data.videos[num]\n                    ));\n                }\n                \"open_menu\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p21\");\n                }\n                \"sounds_and_labels\" => {\n                    // toggle sound and label on/off\n                    websysmod::debug_write(&format!(\"on click sounds and labels: {}\", \"\"));\n                    if rrc.game_data.sounds_and_labels == true {\n                        rrc.game_data.sounds_and_labels = false;\n                    } else {\n                        rrc.game_data.sounds_and_labels = true;\n                    }\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgSoundsAndLabels {\n                                sounds_and_labels: rrc.game_data.sounds_and_labels,\n                            },\n                        });\n                    vdom.schedule_render();\n                }\n                \"back_to_game\" => {\n                    let h = unwrap!(websysmod::window().history());\n                    let _x = h.back();\n                }\n                \"open_instructions\" => {\n                    websysmod::open_new_tab(\"#p08\");\n                }\n                \"debug_log\" => {\n                    websysmod::open_new_tab(\"#p31\");\n                }\n                \"webrtc\" => {\n                    open_new_local_page(\"#p41\");\n                }\n                \"web_rtc_receiver_ws_uid_onkeyup\" => {\n                    webrtcimplmod::web_rtc_receiver_ws_uid_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_start\" => {\n                    rrc.web_data.web_rtc_data\n                        .web_rtc_start(vdom, unwrap!(rrc.web_data.websocket_data.ws.clone()));\n                }\n                \"web_rtc_chat_text_onkeyup\" => {\n                    webrtcimplmod::web_rtc_chat_text_onkeyup(vdom, rrc, event);\n                }\n                \"web_rtc_send_chat\" => {\n                    rrc.web_data.web_rtc_data.web_rtc_send_chat(vdom);\n                }\n                \"start_a_group_onclick\" => {\n                    // entry point for the game\n                    rrc.start_websocket(vdom);\n                    open_new_local_page(\"#p02\");\n                }\n                \"restart_game\" => {\n                    // send a msg to others to open #p04\n                    statusgameovermod::on_msg_play_again(rrc);\n                    open_new_local_page(\"#p02\");\n                }\n                \"join_a_group_onclick\" => {\n                    websysmod::open_new_local_page_push_to_history(\"#p03\");\n                }\n                \"choose_a_game_onclick\" => {\n                    open_new_local_page(\"#p05\");\n                }\n                \"start_game_onclick\" => {\n                    statusgamedatainitmod::on_click_start_game(rrc);\n                    // async fetch all imgs and put them in service worker cache\n                    fetchmod::fetch_all_img_for_cache_request(rrc);\n                    // websysmod::debug_write(&format!(\"start_game_onclick players: {:?}\",rrc.game_data.players));\n                    open_new_local_page(\"#p11\");\n                }\n                \"game_type_right_onclick\" => {\n                    game_type_right_onclick(rrc, vdom);\n                }\n                \"game_type_left_onclick\" => {\n                    game_type_left_onclick(rrc, vdom);\n                }\n                \"join_group_on_click\" => {\n                    open_new_local_page(\"#p04\");\n                }\n                \"drink_end\" => {\n                    // send a msg to end drinking to all players\n\n                    websysmod::debug_write(&format!(\"MsgDrinkEnd send{}\", \"\"));\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgDrinkEnd {},\n                        });\n                    // if all the cards are permanently up, this is the end of the game\n                    // websysmod::debug_write(\"if is_all_permanently(rrc)\");\n                    if status2ndcardmod::is_all_permanently(rrc) {\n                        websysmod::debug_write(\"yes\");\n                        statusgameovermod::on_msg_game_over(rrc);\n                        // send message\n                        rrc.web_data\n                            .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                                msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                                msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                                msg_data: gamedatamod::WsMessageGameData::MsgGameOver {},\n                            });\n                    } else {\n                        statustaketurnmod::on_click_take_turn(rrc, vdom.clone());\n                    }\n                    // end the drink page\n                    open_new_local_page(\"#p11\");\n                }\n                \"p06_load_image\" => {\n                    //websysmod::debug_write(\"p06_load_image\");\n                    statusdrinkmod::play_sound_for_drink(rrc);\n                }\n                \"play_again\" => {\n                    rrc.web_data\n                        .send_ws_msg_from_web_data(&websocketboilermod::WsMessageForReceivers {\n                            msg_sender_ws_uid: rrc.web_data.my_ws_uid,\n                            msg_receivers_json: rrc.web_data.msg_receivers_json.to_string(),\n                            msg_data: gamedatamod::WsMessageGameData::MsgPlayAgain {},\n                        });\n                    rrc.game_data.reset_for_play_again();\n                    open_new_local_page(\"#p05\");\n                }\n                \"on_click_img_status1st\" => {\n                    status1stcardmod::on_click_img_status1st(root, vdom.clone(), &event);\n                }\n                \"on_click_img_status2nd\" => {\n                    status2ndcardmod::on_click_img_status2nd(root, vdom.clone(), &event);\n                }\n                \"hide_big_img\" => {\n                    hide_big_img();\n                }\n                _ => {\n                    let x = format!(\"Error: Unrecognized call_fn_listener: \\\"{}\\\"\", fn_name);\n                    websysmod::debug_write(&x);\n                }\n            }\n        })\n    }\n\n    /// html_templating functions that return a Node\n    #[allow(clippy::needless_return)]\n    fn call_fn_node<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Node<'a> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_container\" => {\n                // what is the game_status now?\n                // websysmod::debug_write(&format!(\"game status: {}\", self.game_data.game_status));\n                let max_grid_size = divgridcontainermod::max_grid_size(self);\n                return divgridcontainermod::div_grid_container(self, cx, &max_grid_size);\n            }\n            \"div_player_action\" => {\n                let node = divplayeractionsmod::div_player_actions_from_game_status(self, cx);\n                return node;\n            }\n            \"svg_qrcode\" => {\n                return svg_qrcode_to_node(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return node;\n            }\n        }\n    }\n\n    /// html_templating functions that return a vector of Nodes\n    #[allow(clippy::needless_return)]\n    fn call_fn_vec_nodes<'a>(&self, cx: &mut RenderContext<'a>, fn_name: &str) -> Vec<Node<'a>> {\n        let bump = cx.bump;\n        // websysmod::debug_write(&format!(\"call_fn_node: {}\", &fn_name));\n        match fn_name {\n            \"div_grid_all_items\" => {\n                return divgridcontainermod::div_grid_all_items(self, cx);\n            }\n            \"web_rtc_div_messages\" => {\n                return webrtcimplmod::web_rtc_div_messages(self, cx);\n            }\n            _ => {\n                let node = ElementBuilder::new(bump, \"h2\")\n                    .children([text(\n                        bumpalo::format!(in bump,\n                            \"Error: Unrecognized call_fn_node: \\\"{}\\\"\",\n                            fn_name\n                        )\n                        .into_bump_str(),\n                    )])\n                    .finish();\n\n                return vec![node];\n            }\n        }\n    }\n}\n\n/// qrcode svg\npub fn svg_qrcode_to_node<'a>(\n    rrc: &RootRenderingComponent,\n    cx: &mut RenderContext<'a>,\n) -> Node<'a> {\n    let link = format!(\"https://bestia.dev/mem6/#p03.{}\", rrc.web_data.my_ws_uid);\n    let qr = unwrap!(qrcode53bytes::Qr::new(&link));\n    let svg_template = qrcode53bytes::SvgDodrioRenderer::new(222, 222).render(&qr);\n    // i added use crate::htmltemplatemod::HtmlTemplating; to make the function render_template in scope.\n    unwrap!(rrc.render_template(cx, &svg_template, htmltemplatemod::HtmlOrSvg::Svg))\n}\n\n/// the arrow to the right\npub fn game_type_right_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.last()).name.to_string();\n    for x in gmd {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// left arrow button\npub fn game_type_left_onclick(rrc: &mut RootRenderingComponent, vdom: VdomWeak) {\n    let gmd = &unwrap!(rrc.game_data.games_metadata.as_ref()).vec_game_metadata;\n    let mut last_name = unwrap!(gmd.first()).name.to_string();\n    for x in gmd.iter().rev() {\n        if rrc.game_data.game_name.as_str() == last_name.as_str() {\n            rrc.game_data.game_name = x.name.to_string();\n            vdom.schedule_render();\n            break;\n        }\n        last_name = x.name.to_string();\n    }\n    fetchmod::async_fetch_game_config_and_update(rrc, vdom);\n}\n\n/// fn open new local page with #\n/// does not push to history\npub fn open_new_local_page(hash: &str) {\n    // I want to put the first url in history.\n    // These are opened from outside my app and I cannot manage that differently.\n    // There are 2 of them:\n    // 1. if the players starts without hash\n    // 2. if the player scanned the qrcode and opened the p3 with group_id\n    // For links opened inside the app, I can call the open with or without history.\n    // For example for menu p21 I want to have a back button.\n    let (_old_location_href, old_href_hash) = websysmod::get_url_and_hash();\n    if old_href_hash.is_empty() || old_href_hash.starts_with(\"#p03.\") {\n        websysmod::open_new_local_page_push_to_history(hash)\n    } else {\n        let _x = websysmod::window().location().replace(hash);\n    }\n}\n\n/// if there is already a group_id don't blink\npub fn blink_or_not_group_id(rrc: &RootRenderingComponent) -> String {\n    if rrc.game_data.group_id == 0 {\n        \"blink\".to_owned()\n    } else {\n        \"\".to_owned()\n    }\n}\n\n/// hide big img\npub fn hide_big_img() {\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    let _x = img_html_element.style().set_property(\"display\", \"none\");\n}\n\n/// visible big img\npub fn visible_big_img(img_file_name: &str) {\n    websysmod::debug_write(img_file_name);\n    //change png in jpg for big img\n    let img_file_name = img_file_name.replace(\".png\", \".jpg\");\n    let img_html_element = websysmod::get_image_element_by_id(\"big_img\");\n    img_html_element.set_src(&img_file_name);\n    let _x = img_html_element.style().set_property(\"display\", \"initial\");\n}\n\n/// update html_template and extract and saves html_sub_templates\n#[allow(clippy::integer_arithmetic)]\n#[allow(clippy::indexing_slicing)]\npub fn update_html_template_and_sub_templates(rrc:&mut RootRenderingComponent, resp_body_text: &str,)  {\n        // only the html inside the <body> </body>\n        let mut tm = between_body_tag(&resp_body_text);\n        // parse and save sub_templates <template name=\"xxx\"></template>\n        rrc.web_data.html_sub_templates.clear();\n        loop {\n            let mut exist_template = false;\n\n            let pos1 = tm.find(\"<template \");\n            let del2 = \"</template>\";\n            let pos2 = tm.find(del2);\n            if let Some(pos_start) = pos1 {\n                if let Some(pos_end) = pos2 {\n                    exist_template = true;\n                    // drain - extract a substring and remove it from the original\n                    let sub1: String = tm.drain(pos_start..pos_end + del2.len()).collect();\n\n                    let del3 = \"name=\\\"\";\n                    let pos_name_start = unwrap!(sub1.find(del3));\n                    let sub2 = &sub1[pos_name_start + del3.len()..];\n                    //websysmod::debug_write(sub2);\n\n                    let pos_name_end = unwrap!(sub2.find('\"'));\n                    let name = &sub2[0..pos_name_end];\n                    //websysmod::debug_write(name);\n\n                    let del5 = '>';\n                    let pos_name_end_tag = unwrap!(sub1.find(del5));\n                    let pos6 = unwrap!(sub1.find(del2));\n                    let sub_template = &sub1[pos_name_end_tag + 1..pos6];\n                    //websysmod::debug_write(sub_template);\n\n                    rrc.web_data\n                        .html_sub_templates\n                        .push((name.to_string(), sub_template.to_string()));\n                }\n            }\n            if !exist_template {\n                break;\n            }\n        }\n        rrc.web_data.html_template = tm;\n}\n\n/// only the html between the <body> </body>\n/// it must be a SINGLE root node\nfn between_body_tag(resp_body_text: &str) -> String {\n    let pos1 = resp_body_text.find(\"<body>\").unwrap_or(0);\n    let pos2 = resp_body_text.find(\"</body>\").unwrap_or(0);\n    // return\n    if pos1 == 0 {\n        resp_body_text.to_string()\n    } else {\n        #[allow(clippy::integer_arithmetic)]\n        {\n            unwrap!(resp_body_text.get(pos1 + 6..pos2)).to_string()\n        }\n    }\n}\n"
    }
  ],
  "description": "The first tour describes the start of the wasm module, the routing, the html templating and finally rendering."
}